<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Michael&#39;s Dev Story</title>
  
  
  <link href="http://michaelhur.github.io/atom.xml" rel="self"/>
  
  <link href="http://michaelhur.github.io/"/>
  <updated>2022-04-21T14:34:10.213Z</updated>
  <id>http://michaelhur.github.io/</id>
  
  <author>
    <name>Michael Hur</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PyMLB: Exploring MLB Data using Python</title>
    <link href="http://michaelhur.github.io/2022/04/21/2021-06-02-PyMLB/"/>
    <id>http://michaelhur.github.io/2022/04/21/2021-06-02-PyMLB/</id>
    <published>2022-04-21T14:34:10.213Z</published>
    <updated>2022-04-21T14:34:10.213Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Sabermetrics-Analysis-of-Baseball"><a href="#Sabermetrics-Analysis-of-Baseball" class="headerlink" title="Sabermetrics: Analysis of Baseball"></a>Sabermetrics: Analysis of Baseball</h3><p>As Bill James said “sabermetrics is the search for objective knowledge about baseball.” <span id="more"></span> Unlike the classical baseball statistics such as win or home run, it aims to derive statistic that can objectively quantify the players’ performance. For example, in 2018 New York Mets’ rookie pitcher Jacob deGrom has the record of 10 wins and 9 losses. Looking at win-loss ratio, it only implies that he is a mediocre pitcher, but he has received Cy Young Award (the Pitcher of the Year) and Rookie of the Year for his outstanding performance. <a href="https://www.fangraphs.com/players/jacob-degrom/10954/stats?position=P">Over the span of four seasons, he has made 78 starts, in which he has only won 36 and lost 42.</a> During those 78 starts, <a href="https://www.espn.com/mlb/story/_/id/31354867/new-york-mets-ace-jacob-degrom-lack-run-support-reaching-new-lows">deGrom only conceived one or less runs in 33 games; yet, he was not able to pick up a win.</a> As the example of Jacob deGrom shows, the classical statistic often fails to correctly reflect the player’s performance. As a result, Sabermetricians have derived statistics such as Wins Above Replacement (WAR), which measures a player’s value as to how many more wins the player contributes to the team in comparison with a replacement player in the same position. deGrom’s WAR was 9.0 in 2018, which in the transfer market translates to approximately $70 million making him one of the most expensive player in the league.</p><h3 id="Where-do-we-get-raw-data"><a href="#Where-do-we-get-raw-data" class="headerlink" title="Where do we get raw data?"></a>Where do we get raw data?</h3><p>Now that we know how important statistics is in baseball and want to be able to compute these more meaningful metrics, we first ened to figure out how to extract raw data. Fortunately, <a href="https://statsapi.mlb.com/api/">Major League Baseball (MLB) has long made its data public</a> and this post will show you the guid on “how to extract data” from the MLB’s stats API, by extracting each batter’s at-bat outcome in the opening game of the 2021 season. </p><p><img src="https://michaelhur.github.io/images/20210602/screenshot1.png" alt="Excerpt from the MLB&#39;s Stats API"></p><h3 id="Understanding-the-API-Schema"><a href="#Understanding-the-API-Schema" class="headerlink" title="Understanding the API Schema"></a>Understanding the API Schema</h3><p>Although we can “brute-force” search every node in the tree until we obtain the desired fruit, the <a href="https://beta-statsapi.mlb.com/docs/">API document</a> actually explains what the available keys are and what parameters the query takes at each level. Since we are interested in finding out the result of each “at-bat” in a specific game, we need to where these “play-by-play” data lies in. A thorough read tells us that such information is stroed under the “game” endpoints which stores all the data pertaining to the “game-level.”<br><img src="https://michaelhur.github.io/images/20210602/screenshot2.png" alt="The &quot;Game&quot; endpoints of the MLB&#39;s Stats API"></p><p>This <code>game</code> key requires a <code>game_pk</code> parameter. <code>game_pk</code> is a unique identifier assigned to each game. In order to obtain this <code>game_pk</code>, we will have to look into the <code>schedule</code> operation, which will return all the game on a given date. In short, in order to get the <code>play-by-play</code> data we will have to:</p><ol><li>From the <code>schedule</code> key, we extract the <code>game_pk</code> of the opening game of 2021 season.</li><li>Using this <code>game_pk</code>, we extract the <code>play-By-Play</code> data of the corresponding <code>game_pk.</code></li></ol><h3 id="Python-Approach"><a href="#Python-Approach" class="headerlink" title="Python Approach"></a>Python Approach</h3><p>We have three goals:</p><ol><li>From the <code>schedule</code> key, we extract the <code>game_pk</code> of the opening game of 2021 season.</li><li>Using this <code>game_pk</code>, we extract the <code>play-By-Play</code> data of the corresponding <code>game_pk.</code></li><li>Putting it all together so that we can extract other data with a simple change to the query.</li></ol><h2 id="Import-Libraries"><a href="#Import-Libraries" class="headerlink" title="Import Libraries"></a>Import Libraries</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure><h3 id="1-Extract-game-pk-from-the-schedule-endpoints"><a href="#1-Extract-game-pk-from-the-schedule-endpoints" class="headerlink" title="1. Extract game_pk from the schedule endpoints"></a>1. Extract <code>game_pk</code> from the <code>schedule</code> endpoints</h3><p>A quick tip: </p><ul><li>The schedule endpoint requires either ‘sportId’ or ‘game_pk’.</li><li>Former will be used to obtain schedule on the given date(s).</li><li>Latter is used to obtain schedule given the unique game ID. Which seems like a backward operation, but think of the scenario where we want to figure out the detailed schedule such as date, venue or home&#x2F;away of the specific game.</li><li>Parameter ‘sportId’ should be 1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Production version url</span></span><br><span class="line">schedule_url = <span class="string">&#x27;http://statsapi.mlb.com/api/v1/schedule?sportId=1&amp;date=04/01/2021&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">schedule_response = requests.get(schedule_url)</span><br><span class="line">schedule_content = schedule_response.content</span><br><span class="line">schedule_json_content = json.loads(schedule_content)</span><br></pre></td></tr></table></figure><p>After a successful load of the content, we want to see what it looks like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schedule_json_content</span><br></pre></td></tr></table></figure><p>A quick skim of the content implies that the most of the contents are under the key “dates.” To check there are more endpoints of the schedule endpoints:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schedule_json_content.keys()</span><br></pre></td></tr></table></figure><p>Since there is no other keys in this json object, we will explore more of the “dates” key.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dates_content = schedule_json_content[<span class="string">&#x27;dates&#x27;</span>]</span><br><span class="line">dates_content</span><br></pre></td></tr></table></figure><p>The output object is a list of json object(s). Since we queried only on a single date, we will have one json object in the list. Each ‘date’ json object has multiple “games” tags. Each tag corresponds to a game played on the given date.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">games_content = dates_content[<span class="number">0</span>][<span class="string">&#x27;games&#x27;</span>]</span><br><span class="line">games_content</span><br></pre></td></tr></table></figure><p>Again, it returns a list of ‘game’ json object. Each ‘game’ object contains the information about each game played on the given date. These information include:</p><ul><li>gamePk: The unique ID assigned to each game</li><li>link: The API link to this game</li><li>gameType: ‘R’ if regular game, ‘P’ if post-season, ‘N’ if pre-season</li><li>gameDate, officialDate: self-explanatory</li><li>status: has children tags such as detailedState, which tells us if the game is finished, cancelled, delayed, etc</li><li>teams: teams played the game, their current standings, scores, home&#x2F;away status</li></ul><p>Since are interested in obtaining ‘gamePk’ of the opening game:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gamePk_opening = games_content[<span class="number">0</span>][<span class="string">&#x27;gamePk&#x27;</span>]</span><br><span class="line">gamePk_opening</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">634642</span></span><br></pre></td></tr></table></figure><p>To sum it up, we can find ‘gamePk’ parameter in the following order:</p><ul><li>schedule -&gt; dates -&gt; games -&gt; gamePk.</li></ul><p>Or (not so) Pythonically:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gamePk_opening_alt = schedule_json_content[<span class="string">&#x27;dates&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;games&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;gamePk&#x27;</span>]</span><br><span class="line">gamePk_opening_alt</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">634642</span></span><br></pre></td></tr></table></figure><h3 id="2-Using-gamePk-to-extract-at-bat-data"><a href="#2-Using-gamePk-to-extract-at-bat-data" class="headerlink" title="2. Using gamePk to extract at-bat data"></a>2. Using <code>gamePk</code> to extract <code>at-bat</code> data</h3><p><a href="https://beta-statsapi.mlb.com/docs/#!/game/playByPlay">The API document</a> says that we need to input the following url:</p><p><code>http://statsapi.mlb.com/api/v1/game/&#123;game_pk&#125;/playByPlay</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">playbyplay_url = <span class="string">&quot;http://statsapi.mlb.com/api/v1/game/634642/playByPlay&quot;</span></span><br></pre></td></tr></table></figure><p>Following the same steps as we did with the schedule endpoints:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">playbyplay_response = requests.get(playbyplay_url)</span><br><span class="line">playbyplay_content = playbyplay_response.content</span><br><span class="line">playbyplay_json_content = json.loads(playbyplay_content)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">playbyplay_json_content</span><br></pre></td></tr></table></figure><p>A quick skim of the content implies that the most of the contents are under the key <code>allPlays</code>. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allPlays_content = playbyplay_json_content[<span class="string">&#x27;allPlays&#x27;</span>]</span><br><span class="line">allPlays_content</span><br></pre></td></tr></table></figure><p>Again, this <code>allPlays</code> object is a list of <code>plays</code>. So we only dig into one for the exploratory work.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Play1 = allPlays_content[<span class="number">0</span>]</span><br><span class="line">Play1</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Play1.keys()</span><br></pre></td></tr></table></figure><p>Looking at the available keys of this endpoint, <code>result</code> key obviously contains the information we want: the outcome of each at bat.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Play1[<span class="string">&#x27;result&#x27;</span>]</span><br></pre></td></tr></table></figure><pre><code>&#123;&#39;type&#39;: &#39;atBat&#39;, &#39;event&#39;: &#39;Groundout&#39;, &#39;eventType&#39;: &#39;field_out&#39;, &#39;description&#39;: &#39;Marcus Semien grounds out, shortstop Gleyber Torres to first baseman Jay Bruce.&#39;, &#39;rbi&#39;: 0, &#39;awayScore&#39;: 0, &#39;homeScore&#39;: 0&#125;</code></pre><p>Here we are. We need to cautious here. <code>type</code> attributes implies that there could be play type that is not <code>atBat</code>.</p><p>So we loop through each play and filter out ones whose type is not <code>atBat</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">play_dict = &#123;&#125;</span><br><span class="line">play_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> play <span class="keyword">in</span> allPlays_content:</span><br><span class="line">    <span class="keyword">if</span> play[<span class="string">&#x27;result&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] != <span class="string">&#x27;atBat&#x27;</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    play_count += <span class="number">1</span></span><br><span class="line">    play_outcome = play[<span class="string">&#x27;result&#x27;</span>][<span class="string">&#x27;eventType&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    play_dict.update(&#123;play_count: play_outcome&#125;)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play_dict</span><br></pre></td></tr></table></figure><pre><code>&#123;1: &#39;field_out&#39;, 2: &#39;strikeout&#39;, 3: &#39;field_out&#39;, 4: &#39;field_out&#39;, 5: &#39;strikeout&#39;, 6: &#39;strikeout&#39;, 7: &#39;single&#39;, 8: &#39;single&#39;, 9: &#39;single&#39;, 10: &#39;field_out&#39;, 11: &#39;strikeout&#39;, 12: &#39;strikeout&#39;, 13: &#39;field_out&#39;, 14: &#39;single&#39;, 15: &#39;strikeout&#39;, 16: &#39;home_run&#39;, 17: &#39;field_out&#39;, 18: &#39;field_out&#39;, 19: &#39;strikeout&#39;, 20: &#39;strikeout&#39;, 21: &#39;field_out&#39;, 22: &#39;field_out&#39;, 23: &#39;field_out&#39;, 24: &#39;strikeout&#39;, 25: &#39;walk&#39;, 26: &#39;strikeout&#39;, 27: &#39;field_out&#39;, 28: &#39;strikeout&#39;, 29: &#39;field_out&#39;, 30: &#39;strikeout&#39;, 31: &#39;field_out&#39;, 32: &#39;single&#39;, 33: &#39;field_out&#39;, 34: &#39;field_out&#39;, 35: &#39;field_out&#39;, 36: &#39;field_out&#39;, 37: &#39;walk&#39;, 38: &#39;single&#39;, 39: &#39;field_out&#39;, 40: &#39;strikeout&#39;, 41: &#39;home_run&#39;, 42: &#39;walk&#39;, 43: &#39;grounded_into_double_play&#39;, 44: &#39;single&#39;, 45: &#39;force_out&#39;, 46: &#39;strikeout&#39;, 47: &#39;walk&#39;, 48: &#39;field_out&#39;, 49: &#39;field_out&#39;, 50: &#39;single&#39;, 51: &#39;field_out&#39;, 52: &#39;caught_stealing_2b&#39;, 53: &#39;single&#39;, 54: &#39;field_out&#39;, 55: &#39;single&#39;, 56: &#39;walk&#39;, 57: &#39;grounded_into_double_play&#39;, 58: &#39;strikeout&#39;, 59: &#39;field_out&#39;, 60: &#39;field_out&#39;, 61: &#39;walk&#39;, 62: &#39;strikeout&#39;, 63: &#39;field_out&#39;, 64: &#39;strikeout&#39;, 65: &#39;single&#39;, 66: &#39;field_out&#39;, 67: &#39;strikeout&#39;, 68: &#39;field_out&#39;, 69: &#39;walk&#39;, 70: &#39;strikeout&#39;, 71: &#39;walk&#39;, 72: &#39;fielders_choice_out&#39;, 73: &#39;strikeout&#39;, 74: &#39;double&#39;, 75: &#39;strikeout&#39;, 76: &#39;strikeout&#39;, 77: &#39;strikeout&#39;, 78: &#39;strikeout&#39;, 79: &#39;strikeout&#39;, 80: &#39;strikeout&#39;&#125;</code></pre><p>Finally, we achieved what we wanted. The outcome of each at-bat.</p><h3 id="3-Putting-it-altogether"><a href="#3-Putting-it-altogether" class="headerlink" title="3. Putting it altogether"></a>3. Putting it altogether</h3><p>First we build a helper function that can be used generally.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_json</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="comment">## get_json: str -&gt; json</span></span><br><span class="line">    <span class="comment">## get_json() function takes &#x27;url&#x27; and returns the response in json format from the MLB Stats API.</span></span><br><span class="line">    </span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> (response.status_code != <span class="number">200</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;status code: %s&#x27;</span> % response.status_code)</span><br><span class="line">        time.sleep(<span class="number">1.0</span>)</span><br><span class="line">        get_json(url)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        content = response.content</span><br><span class="line">        json_content = json.loads(content)</span><br><span class="line">        <span class="keyword">return</span>(json_content)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extract_game_id</span>(<span class="params">schedule_json</span>):</span><br><span class="line">    <span class="comment">## extract_game_id: json -&gt; listof int</span></span><br><span class="line">    <span class="comment">## extract_game_id() function takes a schedule response object and returns a list of game IDs.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> schedule_json == &#123;&#125;:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    gameID_list = []</span><br><span class="line">    </span><br><span class="line">    dates = schedule_json[<span class="string">&#x27;dates&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> day <span class="keyword">in</span> dates:</span><br><span class="line">        games = day[<span class="string">&#x27;games&#x27;</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> game <span class="keyword">in</span> games:</span><br><span class="line">            gameID = game[<span class="string">&#x27;gamePk&#x27;</span>]</span><br><span class="line">            gameID_list.append(gameID)</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(gameID_list)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_game_ids</span>(<span class="params">date, endDate = <span class="literal">None</span>, teamId = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment">## get_game_ids: str int str str -&gt; listof int</span></span><br><span class="line">    <span class="comment">## get_game_ids() function returns the list of game IDs.</span></span><br><span class="line">    <span class="comment">## date must be of format &quot;YYYY-MM-DD&quot;. </span></span><br><span class="line">    <span class="comment">## If date is used without end_date, then it returns the list of game IDs on the input date.</span></span><br><span class="line">    <span class="comment">## If end_date is inputted, then it returns the list of game IDs in the period of date and end_date.</span></span><br><span class="line">    <span class="comment">## If teamID is inputted, then it will return game ID&#x27;s that the corresponding team played; otherwise, all.</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    base_schedule_url = <span class="string">&quot;http://statsapi.mlb.com/api/v1/schedule?sportId=1&quot;</span></span><br><span class="line">    alt_base_url = <span class="string">&quot;https://beta-statsapi.mlb.com:443/api/v1/schedule?sportId=1&quot;</span></span><br><span class="line">    suffix = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> endDate <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        suffix = <span class="string">&quot;&amp;startDate=&quot;</span> + date + <span class="string">&quot;&amp;endDate=&quot;</span> + endDate</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        suffix = <span class="string">&quot;&amp;date=&quot;</span> + date</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> teamId <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        suffix = suffix + <span class="string">&quot;&amp;teamId=&quot;</span> + <span class="built_in">str</span>(teamId)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        url = base_schedule_url + suffix</span><br><span class="line">        <span class="comment">#print(url)</span></span><br><span class="line">        schedule_content = get_json(url)</span><br><span class="line">        <span class="comment">#print(&#x27;status code: %s&#x27; % response.status_code)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment">#print(&#x27;Trying alternate route...&#x27;)</span></span><br><span class="line">        url = alt_base_url + suffix</span><br><span class="line">        <span class="comment">#print(url)</span></span><br><span class="line">        schedule_content = get_json(url)</span><br><span class="line">   </span><br><span class="line">    gameIDs = extract_game_id(schedule_content)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(gameIDs)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_atbat_outcome</span>(<span class="params">listofgameIDs</span>):</span><br><span class="line">    </span><br><span class="line">    gameID_dict = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> gameID <span class="keyword">in</span> listofgameIDs:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            url =  <span class="string">&quot;http://statsapi.mlb.com/api/v1/game/&quot;</span> + <span class="built_in">str</span>(gameID) + <span class="string">&quot;/playByPlay&quot;</span></span><br><span class="line">            playbyplay_content = get_json(url)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="comment">#print(&#x27;Trying alternate route...&#x27;)</span></span><br><span class="line">            url = <span class="string">&quot;https://beta-statsapi.mlb.com:443/api/v1/game&quot;</span> + <span class="built_in">str</span>(gameID) + <span class="string">&quot;/playByPlay&quot;</span></span><br><span class="line">            playbyplay_content = get_json(url)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        allPlays_content = playbyplay_content[<span class="string">&#x27;allPlays&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">        play_dict = &#123;&#125;</span><br><span class="line">        play_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> play <span class="keyword">in</span> allPlays_content:</span><br><span class="line">            <span class="keyword">if</span> play[<span class="string">&#x27;result&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] != <span class="string">&#x27;atBat&#x27;</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">            play_count += <span class="number">1</span></span><br><span class="line">            play_outcome = play[<span class="string">&#x27;result&#x27;</span>][<span class="string">&#x27;eventType&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            play_dict.update(&#123;play_count: play_outcome&#125;)</span><br><span class="line">            </span><br><span class="line">        gameID_dict.update(&#123;gameID:play_dict&#125;)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span>(gameID_dict)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Sabermetrics-Analysis-of-Baseball&quot;&gt;&lt;a href=&quot;#Sabermetrics-Analysis-of-Baseball&quot; class=&quot;headerlink&quot; title=&quot;Sabermetrics: Analysis of Baseball&quot;&gt;&lt;/a&gt;Sabermetrics: Analysis of Baseball&lt;/h3&gt;&lt;p&gt;As Bill James said “sabermetrics is the search for objective knowledge about baseball.”</summary>
    
    
    
    
    <category term="Python" scheme="http://michaelhur.github.io/tags/Python/"/>
    
    <category term="API" scheme="http://michaelhur.github.io/tags/API/"/>
    
    <category term="Wrapper" scheme="http://michaelhur.github.io/tags/Wrapper/"/>
    
    <category term="Baseball" scheme="http://michaelhur.github.io/tags/Baseball/"/>
    
    <category term="MLB" scheme="http://michaelhur.github.io/tags/MLB/"/>
    
    <category term="Data" scheme="http://michaelhur.github.io/tags/Data/"/>
    
  </entry>
  
  <entry>
    <title>PyMLB to plot Pitch f/x data</title>
    <link href="http://michaelhur.github.io/2022/04/21/2021-06-11-Strike%20Zone/"/>
    <id>http://michaelhur.github.io/2022/04/21/2021-06-11-Strike%20Zone/</id>
    <published>2022-04-21T14:34:10.213Z</published>
    <updated>2022-04-21T14:34:10.213Z</updated>
    
    <content type="html"><![CDATA[<p>This time we will look at what the strike zone looks like for a Korean Pitcher “Ryu Hyun-Jin.” </p><span id="more"></span><h4 id="1-Pull-schedule-data"><a href="#1-Pull-schedule-data" class="headerlink" title="1. Pull schedule data"></a>1. Pull schedule data</h4><p>First we need to pull all the game ID for this particular pitcher for this season. Using <a href="https://michaelhur.github.io/PyMLB/">get_schedule() function we coded last time</a>, we will extract schedule data. </p><p>Unfortunately, we can only pull the schedule data at the team level. So we will extract all the game his team “Toronto Blue Jays” has played this season, then filter the games he has played.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bluejays_schedule = get_schedule(teamId = <span class="number">141</span>, startDate = <span class="string">&quot;2021-04-01&quot;</span>, endDate = yesterday)</span><br></pre></td></tr></table></figure><p>The output looks like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">next</span>(<span class="built_in">iter</span>(bluejays_schedule.values()))</span><br></pre></td></tr></table></figure><pre><code>[&#123;&#39;gamePk&#39;: 634642,  &#39;home&#39;: &#123;&#39;ID&#39;: 147, &#39;name&#39;: &#39;New York Yankees&#39;&#125;,  &#39;away&#39;: &#123;&#39;ID&#39;: 141, &#39;name&#39;: &#39;Toronto Blue Jays&#39;&#125;&#125;]</code></pre><p>From this schedule dictionary, we will extract only the <code>gamePk</code> which will be used to pull pitch f&#x2F;x data for that particular game.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gamePks = [v[<span class="number">0</span>][<span class="string">&#x27;gamePk&#x27;</span>] <span class="keyword">for</span> k, v <span class="keyword">in</span> bluejays_schedule.items()]</span><br></pre></td></tr></table></figure><p>And the first 10 gamePk’s look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gamePks[<span class="number">0</span>:<span class="number">10</span>]</span><br></pre></td></tr></table></figure><pre><code>[634642, 634644, 634607, 634612, 634635, 634583, 634545, 634512, 632227, 632208]</code></pre><h4 id="2-Pitch-fx-data"><a href="#2-Pitch-fx-data" class="headerlink" title="2. Pitch fx data"></a>2. Pitch fx data</h4><p>Next step is to extract pitch fx data for each game. We will loop through each of gamePks we obtains above. Again, using get_pitchfx() function we coded last time:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pitchfx = get_pitchfx(<span class="number">634642</span>)</span><br></pre></td></tr></table></figure><p>As a reminder, get_pitchfx() returns pitch f&#x2F;x data as a dictionary object, where each key on the top level corresponds to each “at bat”. The second tier dictionary stores the pitch fx data we want, so we will extact them systematically.</p><p>In order to make analysis easier (or coding for the analysis easier), we will convert this dictionary object to a dataframe object. We remove the non-pitchfx data from the dictionary:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pitches = &#123;k:v <span class="keyword">for</span> k, v <span class="keyword">in</span> pitchfx.items() <span class="keyword">if</span> k != <span class="string">&quot;home_umpire&quot;</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">next</span>(<span class="built_in">iter</span>(pitches.values()))</span><br></pre></td></tr></table></figure><pre><code>&#123;&#39;inning&#39;: 1, &#39;home&#39;: &#39;home&#39;, &#39;pitcher&#39;: &#123;&#39;id&#39;: 543037,  &#39;fullName&#39;: &#39;Gerrit Cole&#39;,  &#39;link&#39;: &#39;/api/v1/people/543037&#39;&#125;, &#39;batter&#39;: &#123;&#39;id&#39;: 543760,  &#39;fullName&#39;: &#39;Marcus Semien&#39;,  &#39;link&#39;: &#39;/api/v1/people/543760&#39;&#125;, &#39;pitchHand&#39;: &#39;R&#39;, &#39;batSide&#39;: &#39;R&#39;, &#39;pitchData&#39;: [&#123;&#39;call&#39;: &#39;ball&#39;,   &#39;sz_top&#39;: 3.25,   &#39;sz_bottom&#39;: 1.53,   &#39;x&#39;: -0.5,   &#39;z&#39;: 3.54&#125;]&#125;</code></pre><p>We will carry (almost) all the data in the dictionary into the dataframe object.</p><ol><li>Define an empty dataframe</li><li>Loop through each at bat</li><li>Loop through each pitch</li><li>Concatenate one row in each loop</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">## Since we are carrying all the information to the dataframe object,</span></span><br><span class="line"><span class="comment">## we will label all the columns as is.</span></span><br><span class="line">pd_index = [<span class="string">&quot;atbat&quot;</span>, <span class="string">&quot;pitchCount&quot;</span>, <span class="string">&quot;inning&quot;</span>, <span class="string">&quot;home&quot;</span>, <span class="string">&quot;pitcher&quot;</span>, <span class="string">&quot;pitcherId&quot;</span>, <span class="string">&quot;pitchHand&quot;</span>,</span><br><span class="line">             <span class="string">&quot;batter&quot;</span>, <span class="string">&quot;batterId&quot;</span>, <span class="string">&quot;batSide&quot;</span>, <span class="string">&quot;sz_top&quot;</span>, <span class="string">&quot;sz_bottom&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;z&quot;</span>, <span class="string">&quot;call&quot;</span>, <span class="string">&quot;actual&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## Create an empty dataframe with only the column names defined.</span></span><br><span class="line">new_df = pd.DataFrame(index = pd_index).T</span><br><span class="line"></span><br><span class="line"><span class="comment">## For loop through each at bat</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> pitches.items():</span><br><span class="line">    atbat = k</span><br><span class="line">    inning = v[<span class="string">&#x27;inning&#x27;</span>]</span><br><span class="line">    home = v[<span class="string">&#x27;home&#x27;</span>]</span><br><span class="line">    pitcher = v[<span class="string">&#x27;pitcher&#x27;</span>][<span class="string">&#x27;fullName&#x27;</span>]</span><br><span class="line">    pitcherId = v[<span class="string">&#x27;pitcher&#x27;</span>][<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">    pitchHand = v[<span class="string">&#x27;pitchHand&#x27;</span>]</span><br><span class="line">    batter = v[<span class="string">&#x27;batter&#x27;</span>][<span class="string">&#x27;fullName&#x27;</span>]</span><br><span class="line">    batterId = v[<span class="string">&#x27;batter&#x27;</span>][<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">    batSide = v[<span class="string">&#x27;batSide&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    pitchCount = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">## For loop through each pitch</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> v[<span class="string">&#x27;pitchData&#x27;</span>]:</span><br><span class="line">        pitchCount += <span class="number">1</span></span><br><span class="line">        sz_top = p[<span class="string">&#x27;sz_top&#x27;</span>]</span><br><span class="line">        sz_bottom = p[<span class="string">&#x27;sz_bottom&#x27;</span>]</span><br><span class="line">        x = p[<span class="string">&#x27;x&#x27;</span>]</span><br><span class="line">        z = p[<span class="string">&#x27;z&#x27;</span>]</span><br><span class="line">        call = p[<span class="string">&#x27;call&#x27;</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">## Given the actual strike zone, determine whether the call made was strike or not</span></span><br><span class="line">        actual = <span class="string">&quot;strike&quot;</span> <span class="keyword">if</span> (sz_bottom &lt;= z &lt;= sz_top) <span class="keyword">and</span> (-<span class="number">0.71</span> &lt; x &lt; <span class="number">0.71</span>) <span class="keyword">else</span> <span class="string">&quot;ball&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">## Each pitch will be turned into a single-row dataframe</span></span><br><span class="line">        new_row = [atbat, pitchCount, inning, home, pitcher, pitcherId, pitchHand,</span><br><span class="line">                   batter, batterId, batSide, sz_top, sz_bottom, x, z, call, actual]</span><br><span class="line"></span><br><span class="line">        new_df1 = pd.DataFrame(new_row, index = pd_index).T</span><br><span class="line">        </span><br><span class="line">        <span class="comment">## This newly defined data frame will be concatenated to the already existing dataframe.</span></span><br><span class="line">        new_df = pd.concat([new_df,new_df1])</span><br><span class="line"></span><br><span class="line"><span class="comment">## New column definitions:</span></span><br><span class="line"><span class="comment">## &#x27;calledRight&#x27;: Each entry is a boolean, whether the call made is correct or not</span></span><br><span class="line">new_df[<span class="string">&#x27;calledRight&#x27;</span>] = (new_df[<span class="string">&#x27;call&#x27;</span>] == new_df[<span class="string">&#x27;actual&#x27;</span>])</span><br><span class="line">new_df[<span class="string">&#x27;umpire&#x27;</span>] = pitchfx[<span class="string">&#x27;home_umpire&#x27;</span>]</span><br><span class="line">new_df.reset_index(drop = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>We will put this into the function so that we can apply it to any other pitch fx data.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">to_df</span>(<span class="params">pitchfx</span>):</span><br><span class="line">    </span><br><span class="line">    pitches = &#123;k:v <span class="keyword">for</span> k, v <span class="keyword">in</span> pitchfx.items() <span class="keyword">if</span> k != <span class="string">&quot;home_umpire&quot;</span>&#125;    </span><br><span class="line"></span><br><span class="line">    pd_index = [<span class="string">&quot;atbat&quot;</span>, <span class="string">&quot;pitchCount&quot;</span>, <span class="string">&quot;inning&quot;</span>, <span class="string">&quot;home&quot;</span>, <span class="string">&quot;pitcher&quot;</span>, <span class="string">&quot;pitcherId&quot;</span>, <span class="string">&quot;pitchHand&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;batter&quot;</span>, <span class="string">&quot;batterId&quot;</span>, <span class="string">&quot;batSide&quot;</span>, <span class="string">&quot;sz_top&quot;</span>, <span class="string">&quot;sz_bottom&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;z&quot;</span>, <span class="string">&quot;call&quot;</span>, <span class="string">&quot;actual&quot;</span>]</span><br><span class="line"></span><br><span class="line">    new_df = pd.DataFrame(index = pd_index).T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> pitches.items():</span><br><span class="line">        atbat = k</span><br><span class="line">        inning = v[<span class="string">&#x27;inning&#x27;</span>]</span><br><span class="line">        home = v[<span class="string">&#x27;home&#x27;</span>]</span><br><span class="line">        pitcher = v[<span class="string">&#x27;pitcher&#x27;</span>][<span class="string">&#x27;fullName&#x27;</span>]</span><br><span class="line">        pitcherId = v[<span class="string">&#x27;pitcher&#x27;</span>][<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">        pitchHand = v[<span class="string">&#x27;pitchHand&#x27;</span>]</span><br><span class="line">        batter = v[<span class="string">&#x27;batter&#x27;</span>][<span class="string">&#x27;fullName&#x27;</span>]</span><br><span class="line">        batterId = v[<span class="string">&#x27;batter&#x27;</span>][<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">        batSide = v[<span class="string">&#x27;batSide&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        pitchCount = <span class="number">0</span>   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> v[<span class="string">&#x27;pitchData&#x27;</span>]:</span><br><span class="line">            pitchCount += <span class="number">1</span></span><br><span class="line">            sz_top = p[<span class="string">&#x27;sz_top&#x27;</span>]</span><br><span class="line">            sz_bottom = p[<span class="string">&#x27;sz_bottom&#x27;</span>]</span><br><span class="line">            x = p[<span class="string">&#x27;x&#x27;</span>]</span><br><span class="line">            z = p[<span class="string">&#x27;z&#x27;</span>]</span><br><span class="line">            call = p[<span class="string">&#x27;call&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            actual = <span class="string">&quot;strike&quot;</span> <span class="keyword">if</span> (sz_bottom &lt;= z &lt;= sz_top) <span class="keyword">and</span> (-<span class="number">0.71</span> &lt; x &lt; <span class="number">0.71</span>) <span class="keyword">else</span> <span class="string">&quot;ball&quot;</span></span><br><span class="line"></span><br><span class="line">            new_row = [atbat, pitchCount, inning, home, pitcher, pitcherId, pitchHand,</span><br><span class="line">                       batter, batterId, batSide, sz_top, sz_bottom, x, z, call, actual]</span><br><span class="line"></span><br><span class="line">            new_df1 = pd.DataFrame(new_row, index = pd_index).T</span><br><span class="line">            new_df = pd.concat([new_df,new_df1])</span><br><span class="line"></span><br><span class="line">    new_df[<span class="string">&#x27;calledRight&#x27;</span>] = (new_df[<span class="string">&#x27;call&#x27;</span>] == new_df[<span class="string">&#x27;actual&#x27;</span>])</span><br><span class="line">    new_df[<span class="string">&#x27;umpire&#x27;</span>] = pitchfx[<span class="string">&#x27;home_umpire&#x27;</span>]</span><br><span class="line">    new_df.reset_index(drop = <span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(new_df)</span><br></pre></td></tr></table></figure><p>Using one of the gamePk, we will try plot pitch fx data. Once succeed, we will apply to all gamePks.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_634642 = to_df(pitchfx)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> plotly.express <span class="keyword">as</span> px</span><br><span class="line"></span><br><span class="line"><span class="comment">## Plot scatter plot, grouped by strike and ball calls</span></span><br><span class="line">fig = px.scatter(df_634642, x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;z&quot;</span>, color=<span class="string">&quot;call&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Draw a rectangle that represents the strike zone</span></span><br><span class="line">fig.add_shape(<span class="built_in">type</span>=<span class="string">&quot;rect&quot;</span>,</span><br><span class="line">    xref = <span class="string">&quot;x&quot;</span>, yref = <span class="string">&quot;y&quot;</span>,</span><br><span class="line">    x0 = -<span class="number">0.71</span>, y0 = <span class="number">1.5</span>,</span><br><span class="line">    x1 = <span class="number">0.71</span>, y1 = <span class="number">3.5</span>,</span><br><span class="line">    line=<span class="built_in">dict</span>(</span><br><span class="line">        color=<span class="string">&quot;RoyalBlue&quot;</span>,</span><br><span class="line">        width=<span class="number">3</span>,</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">fig.update_traces(marker=<span class="built_in">dict</span>(size=<span class="number">12</span>,</span><br><span class="line">                              line=<span class="built_in">dict</span>(width=<span class="number">2</span>,</span><br><span class="line">                                        color=<span class="string">&#x27;DarkSlateGrey&#x27;</span>)),</span><br><span class="line">                  selector=<span class="built_in">dict</span>(mode=<span class="string">&#x27;markers&#x27;</span>))</span><br><span class="line"></span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure><p><img src="https://michaelhur.github.io/images/20210611/1.png"></p><p>In this game, we see quite a number of strikes that were placed well outside the strike zone. On the contrary, we see relatively fewer <code>ball</code> called even if it passed through the strike zone.</p><p>We want to see how they differ depending on home&#x2F;away.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">fig = px.scatter(df_634642, x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;z&quot;</span>, color=<span class="string">&quot;call&quot;</span>, facet_col=<span class="string">&quot;home&quot;</span>,</span><br><span class="line">          labels=&#123;<span class="string">&quot;call&quot;</span>: <span class="string">&quot;Call&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">fig.add_shape(<span class="built_in">type</span>=<span class="string">&quot;rect&quot;</span>,</span><br><span class="line">    xref = <span class="string">&quot;x&quot;</span>, yref = <span class="string">&quot;y&quot;</span>,</span><br><span class="line">    x0 = -<span class="number">0.71</span>, y0 = <span class="number">1.5</span>,</span><br><span class="line">    x1 = <span class="number">0.71</span>, y1 = <span class="number">3.5</span>,</span><br><span class="line">    line=<span class="built_in">dict</span>(</span><br><span class="line">        color=<span class="string">&quot;RoyalBlue&quot;</span>,</span><br><span class="line">        width=<span class="number">3</span>,</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fig.add_shape(<span class="built_in">type</span>=<span class="string">&quot;rect&quot;</span>,</span><br><span class="line">    xref = <span class="string">&quot;x2&quot;</span>, yref = <span class="string">&quot;y&quot;</span>,</span><br><span class="line">    x0 = -<span class="number">0.71</span>, y0 = <span class="number">1.5</span>,</span><br><span class="line">    x1 = <span class="number">0.71</span>, y1 = <span class="number">3.5</span>,</span><br><span class="line">    line=<span class="built_in">dict</span>(</span><br><span class="line">        color=<span class="string">&quot;RoyalBlue&quot;</span>,</span><br><span class="line">        width=<span class="number">3</span>,</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fig.update_traces(marker=<span class="built_in">dict</span>(size=<span class="number">12</span>,</span><br><span class="line">                              line=<span class="built_in">dict</span>(width=<span class="number">2</span>,</span><br><span class="line">                                        color=<span class="string">&#x27;DarkSlateGrey&#x27;</span>)),</span><br><span class="line">                  selector=<span class="built_in">dict</span>(mode=<span class="string">&#x27;markers&#x27;</span>))</span><br><span class="line"></span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure><p><img src="https://michaelhur.github.io/images/20210611/2.png"></p><p>Interestingly, of all pitches placed in the lower right corner of the strike zone, there were more pitches called <code>ball</code> for the away team’s pitcher than the home team’s pitcher.</p><p>Now we look at all the strike calls and see where they landed at.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df_634642[df_634642.call == <span class="string">&quot;strike&quot;</span>][<span class="string">&#x27;calledRight&#x27;</span>].value_counts(normalize = <span class="literal">True</span>)*<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df_634642[df_634642.call == <span class="string">&quot;strike&quot;</span>].groupby([<span class="string">&#x27;home&#x27;</span>])[<span class="string">&#x27;calledRight&#x27;</span>].value_counts(normalize = <span class="literal">True</span>)*<span class="number">100</span>)</span><br></pre></td></tr></table></figure><pre><code>True     52.941176False    47.058824Name: calledRight, dtype: float64home  calledRightaway  True           53.703704      False          46.296296home  True           52.083333      False          47.916667Name: calledRight, dtype: float64</code></pre><p>Interestingly of all <code>strike</code> calls in this game, only 52.9% of the calls were called correctly. In other words, 47.1% of all strike calls should have been called <code>ball</code>.</p><p>On the bright side, the proportion of correctly called strikes to incorrectly called strikes are almost the same at the home&#x2F;away level. So the umpire was not biased againt the away team.</p><p>Visual inspection shows:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">fig = px.scatter(df_634642[df_634642.call == <span class="string">&quot;strike&quot;</span>], x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;z&quot;</span>, color=<span class="string">&quot;calledRight&quot;</span>, facet_col=<span class="string">&quot;home&quot;</span>,</span><br><span class="line">          labels=&#123;<span class="string">&quot;call&quot;</span>: <span class="string">&quot;Call&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">fig.add_shape(<span class="built_in">type</span>=<span class="string">&quot;rect&quot;</span>,</span><br><span class="line">    xref = <span class="string">&quot;x&quot;</span>, yref = <span class="string">&quot;y&quot;</span>,</span><br><span class="line">    x0 = -<span class="number">0.71</span>, y0 = <span class="number">1.5</span>,</span><br><span class="line">    x1 = <span class="number">0.71</span>, y1 = <span class="number">3.5</span>,</span><br><span class="line">    line=<span class="built_in">dict</span>(</span><br><span class="line">        color=<span class="string">&quot;RoyalBlue&quot;</span>,</span><br><span class="line">        width=<span class="number">3</span>,</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fig.add_shape(<span class="built_in">type</span>=<span class="string">&quot;rect&quot;</span>,</span><br><span class="line">    xref = <span class="string">&quot;x2&quot;</span>, yref = <span class="string">&quot;y&quot;</span>,</span><br><span class="line">    x0 = -<span class="number">0.71</span>, y0 = <span class="number">1.5</span>,</span><br><span class="line">    x1 = <span class="number">0.71</span>, y1 = <span class="number">3.5</span>,</span><br><span class="line">    line=<span class="built_in">dict</span>(</span><br><span class="line">        color=<span class="string">&quot;RoyalBlue&quot;</span>,</span><br><span class="line">        width=<span class="number">3</span>,</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fig.update_traces(marker=<span class="built_in">dict</span>(size=<span class="number">12</span>,</span><br><span class="line">                              line=<span class="built_in">dict</span>(width=<span class="number">2</span>,</span><br><span class="line">                                        color=<span class="string">&#x27;DarkSlateGrey&#x27;</span>)),</span><br><span class="line">                  selector=<span class="built_in">dict</span>(mode=<span class="string">&#x27;markers&#x27;</span>))</span><br><span class="line"></span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure><p><img src="https://michaelhur.github.io/images/20210611/3.png"></p><ul><li><p>Looking at the home team pitcher’s strike zone, we see only 3 strike calls that are labelled “incorrectly called” that lie in the strike zone. This is due to the process of fixing the strike zone for all batters. </p></li><li><p>For the home pitchers, most of the incorrectly called strikes are placed on the bottom right corner of the plot. On the other hand, for the away pitchers, it were mostly <code>wide pitches</code> that were called strike incorrectly.</p></li></ul><p>Now look at all the <code>ball</code> calls.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df_634642[df_634642.call == <span class="string">&quot;ball&quot;</span>][<span class="string">&#x27;calledRight&#x27;</span>].value_counts(normalize = <span class="literal">True</span>)*<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df_634642[df_634642.call == <span class="string">&quot;ball&quot;</span>].groupby([<span class="string">&#x27;home&#x27;</span>])[<span class="string">&#x27;calledRight&#x27;</span>].value_counts(normalize = <span class="literal">True</span>)*<span class="number">100</span>)</span><br></pre></td></tr></table></figure><pre><code>True     97.744361False     2.255639Name: calledRight, dtype: float64home  calledRightaway  True           98.717949      False           1.282051home  True           96.363636      False           3.636364Name: calledRight, dtype: float64</code></pre><p>Umpires are doing better job on this side of the call. 97% of all <code>balls</code> are called correctly. My guess is that umpires are more conservative on calling <code>balls</code> than <code>strikes</code>.</p><p>Enough with the opening game of the season, let’s get back in the game. Follow the same process for all of Ryu’s game.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pd_index = [<span class="string">&quot;atbat&quot;</span>, <span class="string">&quot;pitchCount&quot;</span>, <span class="string">&quot;inning&quot;</span>, <span class="string">&quot;home&quot;</span>, <span class="string">&quot;pitcher&quot;</span>, <span class="string">&quot;pitcherId&quot;</span>, <span class="string">&quot;pitchHand&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;batter&quot;</span>, <span class="string">&quot;batterId&quot;</span>, <span class="string">&quot;batSide&quot;</span>, <span class="string">&quot;sz_top&quot;</span>, <span class="string">&quot;sz_bottom&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;z&quot;</span>, <span class="string">&quot;call&quot;</span>, <span class="string">&quot;actual&quot;</span>]</span><br><span class="line"></span><br><span class="line">ryu_df = pd.DataFrame(index = pd_index).T</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> gamePk <span class="keyword">in</span> tqdm(gamePks):</span><br><span class="line">    <span class="comment">#print(gamePk)</span></span><br><span class="line">    df_new = to_df(get_pitchfx(gamePk))</span><br><span class="line">    ryu_df = pd.concat([ryu_df,df_new])</span><br><span class="line"></span><br><span class="line">ryu_df = ryu_df[ryu_df.pitcherId == <span class="number">547943</span>]</span><br><span class="line">ryu_df = ryu_df.reset_index(drop = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><pre><code>100%|██████████| 66/66 [01:14&lt;00:00,  1.13s/it]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fig = px.scatter(ryu_df, x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;z&quot;</span>, color=<span class="string">&quot;call&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.add_shape(<span class="built_in">type</span>=<span class="string">&quot;rect&quot;</span>,</span><br><span class="line">    xref = <span class="string">&quot;x&quot;</span>, yref = <span class="string">&quot;y&quot;</span>,</span><br><span class="line">    x0 = -<span class="number">0.71</span>, y0 = <span class="number">1.5</span>,</span><br><span class="line">    x1 = <span class="number">0.71</span>, y1 = <span class="number">3.5</span>,</span><br><span class="line">    line=<span class="built_in">dict</span>(</span><br><span class="line">        color=<span class="string">&quot;RoyalBlue&quot;</span>,</span><br><span class="line">        width=<span class="number">3</span>,</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">fig.update_traces(marker=<span class="built_in">dict</span>(size=<span class="number">12</span>,</span><br><span class="line">                              line=<span class="built_in">dict</span>(width=<span class="number">2</span>,</span><br><span class="line">                                        color=<span class="string">&#x27;DarkSlateGrey&#x27;</span>)),</span><br><span class="line">                  selector=<span class="built_in">dict</span>(mode=<span class="string">&#x27;markers&#x27;</span>))</span><br><span class="line"></span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure><p><img src="https://michaelhur.github.io/images/20210611/4.png"></p><p>Looking at only the <code>strike</code> calls:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fig = px.scatter(ryu_df[ryu_df[<span class="string">&#x27;call&#x27;</span>] == <span class="string">&#x27;strike&#x27;</span>], x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;z&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.add_shape(<span class="built_in">type</span>=<span class="string">&quot;rect&quot;</span>,</span><br><span class="line">    xref = <span class="string">&quot;x&quot;</span>, yref = <span class="string">&quot;y&quot;</span>,</span><br><span class="line">    x0 = -<span class="number">0.71</span>, y0 = <span class="number">1.5</span>,</span><br><span class="line">    x1 = <span class="number">0.71</span>, y1 = <span class="number">3.5</span>,</span><br><span class="line">    line=<span class="built_in">dict</span>(</span><br><span class="line">        color=<span class="string">&quot;RoyalBlue&quot;</span>,</span><br><span class="line">        width=<span class="number">3</span>,</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">fig.update_traces(marker=<span class="built_in">dict</span>(size=<span class="number">12</span>,</span><br><span class="line">                              line=<span class="built_in">dict</span>(width=<span class="number">2</span>,</span><br><span class="line">                                        color=<span class="string">&#x27;DarkSlateGrey&#x27;</span>)),</span><br><span class="line">                  selector=<span class="built_in">dict</span>(mode=<span class="string">&#x27;markers&#x27;</span>))</span><br><span class="line"></span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure><p><img src="https://michaelhur.github.io/images/20210611/5.png"></p><p>Visual inspection implies that Ryu’s strike zone is wider to both sides. However, when we also look at all the <code>ball</code> calls, we see:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">fig = px.scatter(ryu_df, x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;z&quot;</span>, color=<span class="string">&quot;calledRight&quot;</span>, facet_col=<span class="string">&quot;call&quot;</span>,</span><br><span class="line">          labels=&#123;<span class="string">&quot;calledRight&quot;</span>: <span class="string">&quot;called Right&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">fig.add_shape(<span class="built_in">type</span>=<span class="string">&quot;rect&quot;</span>,</span><br><span class="line">    xref = <span class="string">&quot;x&quot;</span>, yref = <span class="string">&quot;y&quot;</span>,</span><br><span class="line">    x0 = -<span class="number">0.71</span>, y0 = <span class="number">1.5</span>,</span><br><span class="line">    x1 = <span class="number">0.71</span>, y1 = <span class="number">3.5</span>,</span><br><span class="line">    line=<span class="built_in">dict</span>(</span><br><span class="line">        color=<span class="string">&quot;RoyalBlue&quot;</span>,</span><br><span class="line">        width=<span class="number">3</span>,</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fig.add_shape(<span class="built_in">type</span>=<span class="string">&quot;rect&quot;</span>,</span><br><span class="line">    xref = <span class="string">&quot;x2&quot;</span>, yref = <span class="string">&quot;y&quot;</span>,</span><br><span class="line">    x0 = -<span class="number">0.71</span>, y0 = <span class="number">1.5</span>,</span><br><span class="line">    x1 = <span class="number">0.71</span>, y1 = <span class="number">3.5</span>,</span><br><span class="line">    line=<span class="built_in">dict</span>(</span><br><span class="line">        color=<span class="string">&quot;RoyalBlue&quot;</span>,</span><br><span class="line">        width=<span class="number">3</span>,</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fig.update_traces(marker=<span class="built_in">dict</span>(size=<span class="number">12</span>,</span><br><span class="line">                              line=<span class="built_in">dict</span>(width=<span class="number">2</span>,</span><br><span class="line">                                        color=<span class="string">&#x27;DarkSlateGrey&#x27;</span>)),</span><br><span class="line">                  selector=<span class="built_in">dict</span>(mode=<span class="string">&#x27;markers&#x27;</span>))</span><br><span class="line"></span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure><p><img src="https://michaelhur.github.io/images/20210611/6.png"></p><p>Almost all <code>ball</code> calls are called correctly, and there are so many <code>ball</code> calls landed at the same region as those <code>strike</code> calls to the sides of the strike zone. This implies that he has pitches they moves horizontally, leading to <code>swinging strikes</code>.</p><p>These are some of the very few insights one can derive from the visualization of pitch fx data. One can inspect this at the umpire level and see how they perform.</p><h4 id="Try-it-yourself"><a href="#Try-it-yourself" class="headerlink" title="Try it yourself!"></a>Try it yourself!</h4><p>Using the following code, you can try plotting them yourself.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyMLB <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_df</span>(<span class="params">pitchfx</span>):</span><br><span class="line">    </span><br><span class="line">    pitches = &#123;k:v <span class="keyword">for</span> k, v <span class="keyword">in</span> pitchfx.items() <span class="keyword">if</span> k != <span class="string">&quot;home_umpire&quot;</span>&#125;    </span><br><span class="line"></span><br><span class="line">    pd_index = [<span class="string">&quot;atbat&quot;</span>, <span class="string">&quot;pitchCount&quot;</span>, <span class="string">&quot;inning&quot;</span>, <span class="string">&quot;home&quot;</span>, <span class="string">&quot;pitcher&quot;</span>, <span class="string">&quot;pitcherId&quot;</span>, <span class="string">&quot;pitchHand&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;batter&quot;</span>, <span class="string">&quot;batterId&quot;</span>, <span class="string">&quot;batSide&quot;</span>, <span class="string">&quot;sz_top&quot;</span>, <span class="string">&quot;sz_bottom&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;z&quot;</span>, <span class="string">&quot;call&quot;</span>, <span class="string">&quot;actual&quot;</span>]</span><br><span class="line"></span><br><span class="line">    new_df = pd.DataFrame(index = pd_index).T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> pitches.items():</span><br><span class="line">        atbat = k</span><br><span class="line">        inning = v[<span class="string">&#x27;inning&#x27;</span>]</span><br><span class="line">        home = v[<span class="string">&#x27;home&#x27;</span>]</span><br><span class="line">        pitcher = v[<span class="string">&#x27;pitcher&#x27;</span>][<span class="string">&#x27;fullName&#x27;</span>]</span><br><span class="line">        pitcherId = v[<span class="string">&#x27;pitcher&#x27;</span>][<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">        pitchHand = v[<span class="string">&#x27;pitchHand&#x27;</span>]</span><br><span class="line">        batter = v[<span class="string">&#x27;batter&#x27;</span>][<span class="string">&#x27;fullName&#x27;</span>]</span><br><span class="line">        batterId = v[<span class="string">&#x27;batter&#x27;</span>][<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">        batSide = v[<span class="string">&#x27;batSide&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        pitchCount = <span class="number">0</span>   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> v[<span class="string">&#x27;pitchData&#x27;</span>]:</span><br><span class="line">            pitchCount += <span class="number">1</span></span><br><span class="line">            sz_top = p[<span class="string">&#x27;sz_top&#x27;</span>]</span><br><span class="line">            sz_bottom = p[<span class="string">&#x27;sz_bottom&#x27;</span>]</span><br><span class="line">            x = p[<span class="string">&#x27;x&#x27;</span>]</span><br><span class="line">            z = p[<span class="string">&#x27;z&#x27;</span>]</span><br><span class="line">            call = p[<span class="string">&#x27;call&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            actual = <span class="string">&quot;strike&quot;</span> <span class="keyword">if</span> (sz_bottom &lt;= z &lt;= sz_top) <span class="keyword">and</span> (-<span class="number">0.71</span> &lt; x &lt; <span class="number">0.71</span>) <span class="keyword">else</span> <span class="string">&quot;ball&quot;</span></span><br><span class="line"></span><br><span class="line">            new_row = [atbat, pitchCount, inning, home, pitcher, pitcherId, pitchHand,</span><br><span class="line">                       batter, batterId, batSide, sz_top, sz_bottom, x, z, call, actual]</span><br><span class="line"></span><br><span class="line">            new_df1 = pd.DataFrame(new_row, index = pd_index).T</span><br><span class="line">            new_df = pd.concat([new_df,new_df1])</span><br><span class="line"></span><br><span class="line">    new_df[<span class="string">&#x27;calledRight&#x27;</span>] = (new_df[<span class="string">&#x27;call&#x27;</span>] == new_df[<span class="string">&#x27;actual&#x27;</span>])</span><br><span class="line">    new_df[<span class="string">&#x27;umpire&#x27;</span>] = pitchfx[<span class="string">&#x27;home_umpire&#x27;</span>]</span><br><span class="line">    new_df.reset_index(drop = <span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(new_df)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;This time we will look at what the strike zone looks like for a Korean Pitcher “Ryu Hyun-Jin.” &lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://michaelhur.github.io/tags/Python/"/>
    
    <category term="API" scheme="http://michaelhur.github.io/tags/API/"/>
    
    <category term="Wrapper" scheme="http://michaelhur.github.io/tags/Wrapper/"/>
    
    <category term="Baseball" scheme="http://michaelhur.github.io/tags/Baseball/"/>
    
    <category term="MLB" scheme="http://michaelhur.github.io/tags/MLB/"/>
    
    <category term="Data" scheme="http://michaelhur.github.io/tags/Data/"/>
    
    <category term="Plotly" scheme="http://michaelhur.github.io/tags/Plotly/"/>
    
  </entry>
  
  <entry>
    <title>Sudoku: A systemic approach to Sudoku - Part 1</title>
    <link href="http://michaelhur.github.io/2022/04/21/2021-06-22-Sudoku%20-%20Part%20-1/"/>
    <id>http://michaelhur.github.io/2022/04/21/2021-06-22-Sudoku%20-%20Part%20-1/</id>
    <published>2022-04-21T14:34:10.213Z</published>
    <updated>2022-04-21T14:34:10.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Rule-of-Sudoku"><a href="#Rule-of-Sudoku" class="headerlink" title="Rule of Sudoku"></a>Rule of Sudoku</h2><ul><li>Every square has to contain a single number</li><li>Only the numbers between 1 and 9 (inclusive) can be used</li><li>Each 3×3 subgrid can only contain each number from 1 to 9 once</li><li>Each column can only contain each number from 1 to 9 once</li><li>Each row can only contain each number from 1 to 9 once<span id="more"></span></li></ul><h2 id="Approaches"><a href="#Approaches" class="headerlink" title="Approaches"></a>Approaches</h2><p>Given an unsolved sudoku puzzle, our approach is to</p><h3 id="1-Backtracking-i-e-Brute-force"><a href="#1-Backtracking-i-e-Brute-force" class="headerlink" title="1. Backtracking. i.e. Brute-force"></a>1. Backtracking. i.e. Brute-force</h3><ul><li><p>Starting from the top left cell in the puzzle, we go through every unfilled cell from left to right, then top to bottom. </p></li><li><p>Try filling the square with a number between 1 and 9, following the rules stated above. </p></li><li><p>Continue the process until either </p><p>  a) we reach a cell where no possible numeric input exist. go back to the previous supposedly unfilled square, trying with a different number starting there. (i.e. “Backtrack”)</p><p>  b) we reach the last unfilled cell with only one possible input exist. i.e. Sudoku solved!</p></li></ul><h5 id="Aside"><a href="#Aside" class="headerlink" title="Aside:"></a>Aside:</h5><p>Why list over numpy array in this project?</p><p>Numpy arrays are known to be faster than lists. Typically, it is true. But our approach involes assigning new values to entries in the list (or array). In this case, list operation tends to be faster than array operation. </p><p>Checking it out:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">array_test = np.random.randint(low = <span class="number">1</span>, high = <span class="number">9</span>, size=(<span class="number">9</span>,<span class="number">9</span>))</span><br><span class="line">list_test = array_test.tolist()</span><br><span class="line"></span><br><span class="line">%timeit <span class="keyword">for</span> row, col <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">9</span>),<span class="built_in">range</span>(<span class="number">9</span>)): array_test[row,col] = <span class="number">10</span></span><br><span class="line">%timeit <span class="keyword">for</span> row, col <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">9</span>),<span class="built_in">range</span>(<span class="number">9</span>)): list_test[row][col] = <span class="number">10</span></span><br></pre></td></tr></table></figure><pre><code>6.1 µs ± 38.5 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)3.2 µs ± 21.7 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</code></pre><p>As you can see assignment is almost twice faster with list than with numpy arrays. We can add conditional statement within to further test.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%timeit <span class="keyword">for</span> row, col <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">9</span>),<span class="built_in">range</span>(<span class="number">9</span>)): array_test[row,col] = <span class="number">10</span> <span class="keyword">if</span> array_test[row,col] &gt; <span class="number">5</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">%timeit <span class="keyword">for</span> row, col <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">9</span>),<span class="built_in">range</span>(<span class="number">9</span>)): list_test[row][col] = <span class="number">10</span> <span class="keyword">if</span> list_test[row][col] &gt; <span class="number">5</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><pre><code>18.1 µs ± 178 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)5.52 µs ± 159 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</code></pre><p>With the conditional statement, the assignment is three times faster with list than numpy array.</p><h2 id="Backtracking-Algorithm"><a href="#Backtracking-Algorithm" class="headerlink" title="Backtracking Algorithm"></a>Backtracking Algorithm</h2><ol><li><p>Find an unfilled cell in the grid.</p></li><li><p>Enter 1 into the cell. Check if the insertion violates any rule of sudoku. </p><p> a) If it violates. Try inserting 2, 3, 4, … , 9 until the rule is not violated</p><p> b) If it does not violate, proceed to the next empty cell and enter 1, 2, ….</p></li><li><p>Repeat steps 1 and 2 until you reach the last cell in the grid, or no possible input is available for any empty cell.</p></li></ol><h4 id="Helper-Functions"><a href="#Helper-Functions" class="headerlink" title="Helper Functions"></a>Helper Functions</h4><p>We will build helper functions that check rules of sudoku.</p><p>We need to check if the guess we make already exists in the row, column and subgrid we are about to enter into</p><ol><li>Row-wise check</li></ol><p>A row-sie check is pretty simple. Each list within the grid represent a row, so we can do</p><p><code>n in row</code> to check if n (our guess) already exists in the row.</p><ol start="2"><li>Column-wise check</li></ol><p>i-th column of the grid is each represented by the i-th element of each row. That is, we need to loop through each row to extract i-th element of the row, then compute to see if our guess is already in the column.</p><p><code>for row in grid:     if grid[row][i] == n:         return False</code></p><p>or more pythonically:</p><p><code>any([r[col] == n for r in grid])</code></p><p>will check if any of the i-th element of each row is equal to our guess, n.</p><ol start="3"><li>Subgrid check</li></ol><p>Each subgrid is 3x3, with the (row, column) indices <code>[0:3] / [3:6] / [6:9]</code>. Since we only need to check the subgrid the cell belongs to, we will compute where to starting index is:</p><p><code>row_number // 3</code></p><p>will tell whether it is the first, second, or third subgrid vertically (or horizontally if we compute column-wise). Then we multiply it by 3 to find out the index in terms of grid row and column.</p><p><code>row_number // 3 * 3</code></p><p>This will be the starting index of the subgrid, then we add 3 (since it is 3x3 grid) to get the end index. To sum it up,</p><p><code>row_start = row_number // 3 * 3</code></p><p><code>row_end = row_start + 3</code></p><p>WOLG, <code>col_start = col_number // 3 * 3</code> and <code>col_end = col_start + 3</code>.</p><p>We will then loop through each of 9 cells within the subgrid to check if our guess is already in the subgrid.</p><p><code>for r in range(row_start, row_end):     for c in range(col_start, col_end):         if grid[r][c] == n:             return False</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_subgrid</span>(<span class="params">grid, row, col, n</span>):</span><br><span class="line">    <span class="comment">## check_subgrid: listof lists, int, int, int -&gt; boolean</span></span><br><span class="line">    <span class="comment">## This helper function checks if input &quot;n&quot; is in the 3x3 subgrid.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">## We need to find out which region the cell falls in. </span></span><br><span class="line">    r_start = (row // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    c_start = (col // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> r, c <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">3</span>),<span class="built_in">range</span>(<span class="number">3</span>)):</span><br><span class="line">        <span class="keyword">if</span> grid[r_start + r][c_start + c] == n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_row_and_col</span>(<span class="params">grid, row, col, n</span>):</span><br><span class="line">    <span class="comment">## check_row_and_col: list of lists, int, int, int -&gt; boolean</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">## check row-wise</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> grid[row]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">## check row-wise</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">any</span>([r[col] == n <span class="keyword">for</span> r <span class="keyword">in</span> grid]):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>Instead of checking each condition separately, we will do it in one single function.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_conditions</span>(<span class="params">grid, row, col, n</span>):   </span><br><span class="line">    <span class="comment">## check_conditions: list of lists, int, int, int -&gt; boolean</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> grid[row]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">any</span>([r[col] == n <span class="keyword">for</span> r <span class="keyword">in</span> grid]):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    r_start = (row // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    c_start = (col // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> r, c <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">3</span>),<span class="built_in">range</span>(<span class="number">3</span>)):</span><br><span class="line">        <span class="keyword">if</span> grid[r_start + r][c_start + c] == n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">validateSolution</span>(<span class="params">sudoku</span>):</span><br><span class="line">    <span class="comment">## To check if it is a valid solution:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">## If any cell is empty:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">any</span>([<span class="number">0</span> <span class="keyword">in</span> row <span class="keyword">for</span> row <span class="keyword">in</span> sudoku]):</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> sudoku:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> row:</span><br><span class="line">                <span class="keyword">return</span>(<span class="literal">False</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> [r[col] <span class="keyword">for</span> r <span class="keyword">in</span> sudoku]:</span><br><span class="line">                    <span class="keyword">return</span>(<span class="literal">False</span>)</span><br><span class="line">                </span><br><span class="line">    </span><br><span class="line">        <span class="comment">## In fact, if row and column-wise conditions are met, then subgrid condition is automatically met. </span></span><br><span class="line">        <span class="comment">## But we want to check it explicitly.</span></span><br><span class="line">        <span class="keyword">for</span> r_start, c_start <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">3</span>),<span class="built_in">range</span>(<span class="number">3</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">any</span>([n <span class="keyword">not</span> <span class="keyword">in</span> row[c_start * <span class="number">3</span>: c_start * <span class="number">3</span> + <span class="number">3</span>] <span class="keyword">for</span> row <span class="keyword">in</span> grid[r_start * <span class="number">3</span>: r_start * <span class="number">3</span> + <span class="number">3</span>]]):</span><br><span class="line">                <span class="keyword">return</span>(<span class="literal">False</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="Sudoku-Solver"><a href="#Sudoku-Solver" class="headerlink" title="Sudoku Solver"></a>Sudoku Solver</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">next_empty</span>(<span class="params">grid</span>):</span><br><span class="line">    <span class="comment">## next_empty(): listof lists -&gt; int, int</span></span><br><span class="line">    <span class="comment">## next_empty() is a helper function that searches for the next empty cell in the given sudoku puzzle</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> grid:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">in</span> row:</span><br><span class="line">            <span class="keyword">return</span> (grid.index(row), row.index(<span class="number">0</span>))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve_sudoku</span>(<span class="params">grid</span>):</span><br><span class="line">    <span class="comment">## solve_sudoku: listof lists -&gt; listof lists</span></span><br><span class="line">    <span class="comment">## solve_sudoku uses backtracking algorithm to solve the sudoku puzzle</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">## 1. Find the next empty cell.    </span></span><br><span class="line">    row, col = next_empty(grid)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">## If there is no empty cell, it means that all cells are filled. i.e. Sudoku Solved!</span></span><br><span class="line">    <span class="keyword">if</span> row <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">        <span class="keyword">return</span>(grid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>): </span><br><span class="line">        <span class="comment">## 2. Enter 1, 2, 3, .... in the empty cell and check if it violates any rule.</span></span><br><span class="line">        <span class="keyword">if</span> check_conditions(grid, row, col, n):</span><br><span class="line">            </span><br><span class="line">            <span class="comment">## 3. If it does not violate the rules, then assign the value to the cell.</span></span><br><span class="line">            grid[row][col] = n</span><br><span class="line">            </span><br><span class="line">            <span class="comment">## 4. Proceed to the next cell recursively.</span></span><br><span class="line">            <span class="keyword">if</span> solve_sudoku(grid):</span><br><span class="line">                <span class="keyword">return</span>(grid)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">## If it violates any of the rules or does not have solution, empty the cell, </span></span><br><span class="line">        <span class="comment">## trying with different input</span></span><br><span class="line">        grid[row][col] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## 6. No possible combination of inputs solve the sudoku. i.e. No solution.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">grid = np.array([[<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                 [<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                 [<span class="number">0</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>],</span><br><span class="line">                 [<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>],</span><br><span class="line">                 [<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">                 [<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>],</span><br><span class="line">                 [<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>],</span><br><span class="line">                 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>],</span><br><span class="line">                 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line">grid = grid.tolist()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solve_sudoku(grid)</span><br></pre></td></tr></table></figure><pre><code>[[5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">grid2 = np.array([[<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">9</span>],</span><br><span class="line">                 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>],</span><br><span class="line">                 [<span class="number">1</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>],</span><br><span class="line">                 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">                 [<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                 [<span class="number">9</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">8</span>],</span><br><span class="line">                 [<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">grid2 = grid2.tolist()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solve_sudoku(grid2)</span><br></pre></td></tr></table></figure><pre><code>[[3, 2, 9, 5, 6, 1, 4, 8, 7], [8, 1, 6, 4, 3, 7, 2, 5, 9], [7, 4, 5, 8, 9, 2, 1, 6, 3], [1, 9, 7, 3, 4, 8, 5, 2, 6], [6, 8, 2, 1, 5, 9, 3, 7, 4], [4, 5, 3, 7, 2, 6, 8, 9, 1], [2, 6, 1, 9, 8, 3, 7, 4, 5], [9, 3, 4, 2, 7, 5, 6, 1, 8], [5, 7, 8, 6, 1, 4, 9, 3, 2]]</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Rule-of-Sudoku&quot;&gt;&lt;a href=&quot;#Rule-of-Sudoku&quot; class=&quot;headerlink&quot; title=&quot;Rule of Sudoku&quot;&gt;&lt;/a&gt;Rule of Sudoku&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Every square has to contain a single number&lt;/li&gt;
&lt;li&gt;Only the numbers between 1 and 9 (inclusive) can be used&lt;/li&gt;
&lt;li&gt;Each 3×3 subgrid can only contain each number from 1 to 9 once&lt;/li&gt;
&lt;li&gt;Each column can only contain each number from 1 to 9 once&lt;/li&gt;
&lt;li&gt;Each row can only contain each number from 1 to 9 once</summary>
    
    
    
    
    <category term="Python" scheme="http://michaelhur.github.io/tags/Python/"/>
    
    <category term="Sudoku" scheme="http://michaelhur.github.io/tags/Sudoku/"/>
    
    <category term="Bruteforce" scheme="http://michaelhur.github.io/tags/Bruteforce/"/>
    
    <category term="Backtracking" scheme="http://michaelhur.github.io/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Sudoku: A systemic approach to Sudoku - Part 2</title>
    <link href="http://michaelhur.github.io/2022/04/21/2021-06-23-Sudoku%20-%20Part%202/"/>
    <id>http://michaelhur.github.io/2022/04/21/2021-06-23-Sudoku%20-%20Part%202/</id>
    <published>2022-04-21T14:34:10.213Z</published>
    <updated>2022-04-21T14:34:10.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Rule-of-Sudoku"><a href="#Rule-of-Sudoku" class="headerlink" title="Rule of Sudoku"></a>Rule of Sudoku</h2><ul><li>Every square has to contain a single number</li><li>Only the numbers between 1 and 9 (inclusive) can be used</li><li>Each 3×3 subgrid can only contain each number from 1 to 9 once</li><li>Each column can only contain each number from 1 to 9 once</li><li>Each row can only contain each number from 1 to 9 once<span id="more"></span></li></ul><h2 id="Approaches"><a href="#Approaches" class="headerlink" title="Approaches"></a>Approaches</h2><p>Given an unsolved sudoku puzzle, our approach is to</p><h3 id="2-Crook’s-algorithm"><a href="#2-Crook’s-algorithm" class="headerlink" title="2. Crook’s algorithm"></a>2. <a href="https://www.ams.org/notices/200904/rtx090400460p.pdf">Crook’s algorithm</a></h3><p>Crook’s algorithm is basically is how a human being would solve the problem. There are a few terms that we need to define in order to put them together</p><ol><li><code>Mark-up</code>: a <code>mark-up</code> of a cell is a list of all the possible given the numbers that are already in the grid. For example, the <code>mark-up</code> of the very first cell of the grid below is <code>5</code> and <code>7</code>. We can use mark-up instead of trying each number between 1 and 9. This means a fewer cheks to do and shorter computing time.</li></ol><p><img src="http://pi.math.cornell.edu/~mec/Summer2009/meerkamp/Site/Solving_any_Sudoku_II_files/markup.png" alt="An example of mark-up"></p><ol start="2"><li><p><code>Preemptive set</code> is a list of <code>k</code> numbers (2 &lt;&#x3D; k &lt;&#x3D; 8), each between 1 and 9, with the property that only those k numbers can fill k cells. For example, <code>mark-ups</code> in cell (1,1) and (2,1) for a preemptive set of (5, 7). Those <code>2</code> cells can be filled in by only (5, 7) which is a set of <code>2</code> numbers. </p><p> This might sound ambiguous, but is very useful when eliminating candidates from the mark-up of a cell in the same column (or row or 3x3 subgrid). Since numbers 5 and 7 must each occupy one of cells (1, 1) and (2, 1), 5 cannot be in the cell (8,1) in the same column. 5 is then eliminated from the <code>mark-up</code> of the cell (8,1), leaving it with the only one candidate 4. i.e. the cell (8,1) must be filled with 4.</p></li></ol><p><img src="http://pi.math.cornell.edu/~mec/Summer2009/meerkamp/Site/Solving_any_Sudoku_II_files/preemptive_odd.png" alt="An example of preemptive set"></p><h4 id="Crook’s-Algorithm"><a href="#Crook’s-Algorithm" class="headerlink" title="Crook’s Algorithm"></a>Crook’s Algorithm</h4><ol><li><p>Mark up all the empty cells.</p><p> a) If the mark-up consists of only one number, fill in the cell with the number.</p><p> b) Remove such number from the mark-up of the cells in the same row, column and subgrid.</p></li><li><p>Find preemptive sets.</p><p> a) Whenever a preemptive set is found, cross out the numbers in the preemptive set from the <code>mark-up</code> of the cells in the same row, column or subgrid.</p><p> b) Repeat until you find no more preemtive set or rule of Sudoku is violated.</p></li><li><p>If the sudoku is not solved by then, or rule of sudoku has not been violated, apply backtracking method from here, but only using the numbers the mark-up instead of all the numbers from 1 to 9.</p></li></ol><h4 id="Helper-Functions"><a href="#Helper-Functions" class="headerlink" title="Helper Functions"></a>Helper Functions</h4><p>We will build helper functions that check rules of sudoku.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## This puts above two rule checkers together into one function.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_conditions</span>(<span class="params">grid, row, col, n</span>):   </span><br><span class="line">    <span class="comment">## check_conditions: list of lists, int, int, int -&gt; boolean</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> grid[row]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">any</span>([r[col] == n <span class="keyword">for</span> r <span class="keyword">in</span> grid]):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    r_start = (row // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    c_start = (col // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> r, c <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">3</span>),<span class="built_in">range</span>(<span class="number">3</span>)):</span><br><span class="line">        <span class="keyword">if</span> grid[r_start + r][c_start + c] == n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">next_empty</span>(<span class="params">grid</span>):</span><br><span class="line">    <span class="comment">## next_empty(): listof lists -&gt; int, int</span></span><br><span class="line">    <span class="comment">## next_empty() is a helper function that searches for the next empty cell in the given sudoku puzzle</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> grid:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">in</span> row:</span><br><span class="line">            <span class="keyword">return</span> (grid.index(row), row.index(<span class="number">0</span>))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">validateSolution</span>(<span class="params">sudoku</span>):</span><br><span class="line">    <span class="comment">## To check if it is a valid solution:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">## If any cell is empty:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">any</span>([<span class="number">0</span> <span class="keyword">in</span> row <span class="keyword">for</span> row <span class="keyword">in</span> sudoku]):</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> sudoku:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> row:</span><br><span class="line">                <span class="keyword">return</span>(<span class="literal">False</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> [r[col] <span class="keyword">for</span> r <span class="keyword">in</span> sudoku]:</span><br><span class="line">                    <span class="keyword">return</span>(<span class="literal">False</span>)</span><br><span class="line">                </span><br><span class="line">    </span><br><span class="line">        <span class="comment">## In fact, if row and column-wise conditions are met, then subgrid condition is automatically met. </span></span><br><span class="line">        <span class="comment">## But we want to check it explicitly.</span></span><br><span class="line">        <span class="keyword">for</span> r_start, c_start <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">3</span>),<span class="built_in">range</span>(<span class="number">3</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">any</span>([n <span class="keyword">not</span> <span class="keyword">in</span> row[c_start * <span class="number">3</span>: c_start * <span class="number">3</span> + <span class="number">3</span>] <span class="keyword">for</span> row <span class="keyword">in</span> grid[r_start * <span class="number">3</span>: r_start * <span class="number">3</span> + <span class="number">3</span>]]):</span><br><span class="line">                <span class="keyword">return</span>(<span class="literal">False</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="Crook’s-Algorithm-1"><a href="#Crook’s-Algorithm-1" class="headerlink" title="Crook’s Algorithm"></a>Crook’s Algorithm</h2><ol><li><p>Mark up all the empty cells.</p><p> a) If the mark-up consists of only one number, fill in the cell with the number.</p><p> b) Remove such number from the mark-up of the cells in the same row, column and subgrid.</p></li><li><p>Find preemptive sets.</p><p> a) Whenever a preemptive set is found, cross out the numbers in the preemptive set from the <code>mark-up</code> of the cells in the same row, column or subgrid.</p><p> b) Repeat until you find no more preemtive set or rule of Sudoku is violated.</p></li><li><p>If the sudoku is not solved by then, or rule of sudoku has not been violated, pick any empty cell. Make a guess (i.e. pick a number from the markups), then repeat steps 1 and 2 until you can reduce it as much as possible. Repeat step 3 until the rule is violated or the puzzle is solved.</p></li></ol><h4 id="Breakdowns"><a href="#Breakdowns" class="headerlink" title="Breakdowns:"></a>Breakdowns:</h4><h4 id="Mark-up"><a href="#Mark-up" class="headerlink" title="Mark up"></a>Mark up</h4><ol><li>Define a function that finds the mark-up of an empty cell.</li></ol><ul><li><p>check_conditions() function come in handy.</p></li><li><p>Hunch is that we find the row and column index of an empty cell using the next_empty() function, then use check_conditions() function to find mark-ups.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grid = [[<span class="number">2</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">8</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">9</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure><p>Or more easier to read:</p><p><img src="http://pi.math.cornell.edu/~mec/Summer2009/meerkamp/Site/Solving_any_Sudoku_II_files/mepham_imcomp_real.png" alt="An example of mark-up"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Working with one empty cell. The last cell in the first row.</span></span><br><span class="line">r1, c1 = <span class="number">0</span>, <span class="number">8</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools </span><br><span class="line"></span><br><span class="line">markup = []</span><br><span class="line"><span class="keyword">for</span> candidate <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> check_conditions(grid, r1, c1, candidate):</span><br><span class="line">        markup.append(candidate)</span><br><span class="line">    </span><br><span class="line">markup</span><br></pre></td></tr></table></figure><pre><code>[1, 3, 4]</code></pre><p>In order to apply this We cannot use next_empty() without making some manipulation to the function, since there is no insertion at this point. So we will simply loop through each and every cell for the time being</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">markup_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    r = [[]]*<span class="number">9</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        markup = []</span><br><span class="line">        <span class="keyword">if</span> grid[row][col] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> candidate <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> check_conditions(grid, row, col, candidate):</span><br><span class="line">                markup.append(candidate)</span><br><span class="line"></span><br><span class="line">        r[col] = markup</span><br><span class="line"></span><br><span class="line">    markup_list.append(r)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">markup_list</span><br></pre></td></tr></table></figure><pre><code>[[[], [], [], [], [3, 4], [1, 3, 4], [], [], [1, 3, 4]], [[4, 7], [], [], [], [], [], [4, 9], [], [4, 7]], [[],  [4, 7],  [],  [1, 2, 4, 9],  [2, 3, 4, 9],  [1, 2, 3, 4, 9],  [4, 5, 9],  [1, 3, 4, 9],  [1, 3, 4, 5, 7]], [[1, 3, 4, 9],  [1, 4, 8],  [],  [2, 4, 9],  [],  [2, 4, 9],  [2, 4, 9],  [1, 3, 4, 8, 9],  []], [[1, 4, 6, 9],  [1, 4, 6],  [2, 9],  [],  [],  [],  [2, 4, 5, 9],  [1, 4, 9],  [1, 4, 5]], [[], [4, 8], [2, 3, 8, 9], [2, 4, 9], [], [], [], [3, 4, 8, 9], [3, 4, 8]], [[3, 6, 7], [6, 7, 8], [3, 8], [], [2, 3, 4, 7], [2, 3, 4], [], [4, 8], []], [[1, 7, 9], [], [8, 9], [], [4, 7, 9], [1, 4, 9], [], [], [4, 8]], [[1, 3, 9], [], [], [1, 9], [3, 9], [], [], [], []]]</code></pre><p><img src="http://pi.math.cornell.edu/~mec/Summer2009/meerkamp/Site/Solving_any_Sudoku_II_files/mepham_markup.png"></p><p>Putting it into a function so that we can use it repeatedly.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_markup</span>(<span class="params">grid</span>):</span><br><span class="line">    <span class="comment">## get_markup(): listof listof int -&gt; listof listof int</span></span><br><span class="line">    <span class="comment">## This helper function returns a list of list of integers</span></span><br><span class="line">    <span class="comment">## where each list of integer is a markup of a corresponding cell </span></span><br><span class="line">    markup_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        r = [[]]*<span class="number">9</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            markup = []</span><br><span class="line">            <span class="keyword">if</span> grid[row][col] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> candidate <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span> check_conditions(grid, row, col, candidate):</span><br><span class="line">                    markup.append(candidate)</span><br><span class="line"></span><br><span class="line">            r[col] = markup</span><br><span class="line"></span><br><span class="line">        markup_list.append(r)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span>(markup_list)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">markups = get_markup(grid)</span><br><span class="line">markups</span><br></pre></td></tr></table></figure><pre><code>[[[], [], [], [], [3, 4], [1, 3, 4], [], [], [1, 3, 4]], [[4, 7], [], [], [], [], [], [4, 9], [], [4, 7]], [[],  [4, 7],  [],  [1, 2, 4, 9],  [2, 3, 4, 9],  [1, 2, 3, 4, 9],  [4, 5, 9],  [1, 3, 4, 9],  [1, 3, 4, 5, 7]], [[1, 3, 4, 9],  [1, 4, 8],  [],  [2, 4, 9],  [],  [2, 4, 9],  [2, 4, 9],  [1, 3, 4, 8, 9],  []], [[1, 4, 6, 9],  [1, 4, 6],  [2, 9],  [],  [],  [],  [2, 4, 5, 9],  [1, 4, 9],  [1, 4, 5]], [[], [4, 8], [2, 3, 8, 9], [2, 4, 9], [], [], [], [3, 4, 8, 9], [3, 4, 8]], [[3, 6, 7], [6, 7, 8], [3, 8], [], [2, 3, 4, 7], [2, 3, 4], [], [4, 8], []], [[1, 7, 9], [], [8, 9], [], [4, 7, 9], [1, 4, 9], [], [], [4, 8]], [[1, 3, 9], [], [], [1, 9], [3, 9], [], [], [], []]]</code></pre><h4 id="Preemptive-set"><a href="#Preemptive-set" class="headerlink" title="Preemptive set"></a>Preemptive set</h4><p>Here, we will work with the markups to find the preemptive set. First we will try to find the preemptive set then find a way to find smaller set by eliminating.</p><p>For a list of m numbers to be preemptive, it must have m different cells with the same m markups.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## r2 is the second row of the grid</span></span><br><span class="line">r2 =   [[<span class="number">4</span>, <span class="number">7</span>], [], [], [], [], [], [<span class="number">4</span>, <span class="number">9</span>], [], [<span class="number">4</span>, <span class="number">7</span>]]</span><br><span class="line">r2</span><br></pre></td></tr></table></figure><pre><code>[[4, 7], [], [], [], [], [], [4, 9], [], [4, 7]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">preemptive_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> r2:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(m) != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(m) == r2.count(m):</span><br><span class="line">            <span class="keyword">if</span> m <span class="keyword">not</span> <span class="keyword">in</span> preemptive_list:</span><br><span class="line">                preemptive_list.append(m)</span><br><span class="line">                </span><br><span class="line">preemptive_list            </span><br></pre></td></tr></table></figure><pre><code>[[4, 7]]</code></pre><p>Now we want to eliminate these numbers from other cell’s markups.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> preemptive_list:</span><br><span class="line">    <span class="built_in">print</span>([[y <span class="keyword">for</span> y <span class="keyword">in</span> x <span class="keyword">if</span> (y <span class="keyword">not</span> <span class="keyword">in</span> p)] <span class="keyword">if</span> x != p <span class="keyword">else</span> p <span class="keyword">for</span> x <span class="keyword">in</span> r2])</span><br></pre></td></tr></table></figure><pre><code>[[4, 7], [], [], [], [], [], [9], [], [4, 7]]</code></pre><p>This can be easily manipulated to be applied to column-wise and subgrid-wise operation.</p><p>Putting it altogether so that we find preemptive sets for each column, row and subgrid, then eliminate markups using those preemptive sets.</p><p>We will first define functions to do so:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_preemptive</span>(<span class="params">listofMarkup</span>):</span><br><span class="line">    </span><br><span class="line">    preemptive_list = []</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> listofMarkup:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(m) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(m) == listofMarkup.count(m):</span><br><span class="line">                <span class="keyword">if</span> m <span class="keyword">not</span> <span class="keyword">in</span> preemptive_list:</span><br><span class="line">                    preemptive_list.append(m)</span><br><span class="line">    <span class="keyword">return</span>(preemptive_list)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_preemptive(get_markup(grid)[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><pre><code>[[4, 7]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reduce_markup</span>(<span class="params">listofMarkup, preemptive_list</span>):</span><br><span class="line">    <span class="comment"># compute row-, col- or subgrid-wise</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preemptive_list) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span>(listofMarkup)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> preemptive_list:</span><br><span class="line">        <span class="keyword">return</span>([[m <span class="keyword">for</span> m <span class="keyword">in</span> l <span class="keyword">if</span> (m <span class="keyword">not</span> <span class="keyword">in</span> p)] <span class="keyword">if</span> l != p <span class="keyword">else</span> p <span class="keyword">for</span> l <span class="keyword">in</span> listofMarkup])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grid = [[<span class="number">2</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">8</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">9</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce_markup(get_markup(grid)[<span class="number">1</span>], get_preemptive(get_markup(grid)[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><pre><code>[[4, 7], [], [], [], [], [], [9], [], [4, 7]]</code></pre><h4 id="Now-putting-it-all-together…"><a href="#Now-putting-it-all-together…" class="headerlink" title="Now putting it all together…"></a>Now putting it all together…</h4><ol><li><p>We will find markups for all empty cells in the grid</p></li><li><p>Find preemptive sets for all rows, columns and subgrids, then eliminate candidates from markups</p></li><li><p>If only the markup consists of only one candidate, fill in the cell with such number, then remove this number from all markups in the same row, column and subgrid.</p></li><li><p>Repeat until we cannot reduce the markups</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    markup = markups[row]</span><br><span class="line">    preemptives = get_preemptive(markup)</span><br><span class="line">    markup = reduce_markup(markup, preemptives)</span><br></pre></td></tr></table></figure><p>This line will eliminate markups using preemptive sets in each row. Column can be done in the same manner. We will use <code>list(map(list, zip(*l)))</code>, where <code>l</code> is a list of our interest, to transpose the list. Will do the same as we do with the row-wise operation, then transpose back.</p><p>For the subgrid, we will use list index to extract the 3x3 subgrid, find preemptive sets and reduce markups, row by row but with only 3 markups per row.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> r_s, c_s <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">3</span>), <span class="built_in">range</span>(<span class="number">3</span>)):</span><br><span class="line">    markup = [r[c_s * <span class="number">3</span>:c_s * <span class="number">3</span> + <span class="number">3</span>] <span class="keyword">for</span> r <span class="keyword">in</span> markups[r_s * <span class="number">3</span>:r_s * <span class="number">3</span> + <span class="number">3</span>]]</span><br><span class="line">    markup = <span class="built_in">list</span>(itertools.chain(*markup))</span><br><span class="line">    preemptives = get_preemptive(markup)</span><br><span class="line">    markup = reduce_markup(markup, preemptives)</span><br><span class="line">    <span class="comment">#print(markup)</span></span><br><span class="line">    <span class="comment">#markup_subgrid = [markup[k*3:k*3+3] for k in range(3)]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        markups[r_s * <span class="number">3</span> + i][c_s * <span class="number">3</span>: c_s * <span class="number">3</span> + <span class="number">3</span>] = markup[i * <span class="number">3</span>:i * <span class="number">3</span> + <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>Putting it all together. This block of codes will keep reducing until we cannot reduce markups. Note that we will enter the markup into the grid if there is only one candidate for the cell. We will define a function that will find a cell with only one candidate, in the similar manner as the next_empty() function in the previous part.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">markups = get_markup(grid)</span><br><span class="line">[[<span class="built_in">len</span>(m) <span class="keyword">for</span> m <span class="keyword">in</span> listofm] <span class="keyword">for</span> listofm <span class="keyword">in</span> markups]</span><br></pre></td></tr></table></figure><pre><code>[[0, 0, 0, 0, 2, 3, 0, 0, 3], [3, 0, 0, 0, 0, 0, 2, 0, 3], [0, 4, 0, 4, 4, 5, 3, 4, 5], [5, 4, 0, 3, 0, 3, 3, 5, 0], [4, 3, 2, 0, 0, 0, 4, 3, 3], [0, 3, 4, 3, 0, 0, 0, 4, 3], [4, 4, 2, 0, 4, 3, 0, 2, 0], [4, 0, 2, 0, 3, 3, 0, 0, 2], [3, 0, 0, 2, 2, 0, 0, 0, 0]]</code></pre><p>This line gives the length (or the number of) of markups in each cell. 0 implies the cell that is already filled in.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">grid = [[<span class="number">2</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">8</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">9</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">markups = get_markup(grid)</span><br><span class="line">previous_markups = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">next_definite</span>(<span class="params">markups</span>):</span><br><span class="line">    markup_len = [[<span class="built_in">len</span>(m) <span class="keyword">for</span> m <span class="keyword">in</span> listofm] <span class="keyword">for</span> listofm <span class="keyword">in</span> markups]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> markup_len:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">1</span> <span class="keyword">in</span> row:</span><br><span class="line">            <span class="keyword">return</span> (markup_len.index(row), row.index(<span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> markups != previous_markups:</span><br><span class="line">    </span><br><span class="line">    previous_markups = markups</span><br><span class="line">    </span><br><span class="line">    def_row, def_col = next_definite(markups)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> def_row <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        grid[def_row][def_col] = markups[def_row][def_col][<span class="number">0</span>]</span><br><span class="line">        markups = get_markup(grid)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        markup = markups[row]</span><br><span class="line">        preemptives = get_preemptive(markup)</span><br><span class="line">        markup = reduce_markup(markup, preemptives)</span><br><span class="line">        markups[row] = markup</span><br><span class="line">    </span><br><span class="line">    markups = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">list</span>, <span class="built_in">zip</span>(*markups)))</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        markup = markups[col]</span><br><span class="line">        preemptives = get_preemptive(markup)</span><br><span class="line">        markup = reduce_markup(markup, preemptives)</span><br><span class="line">        markups[col] = markup</span><br><span class="line">    markups = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">list</span>, <span class="built_in">zip</span>(*markups))) </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> r_s, c_s <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">3</span>), <span class="built_in">range</span>(<span class="number">3</span>)):</span><br><span class="line">        markup = [r[c_s * <span class="number">3</span>:c_s * <span class="number">3</span> + <span class="number">3</span>] <span class="keyword">for</span> r <span class="keyword">in</span> markups[r_s * <span class="number">3</span>:r_s * <span class="number">3</span> + <span class="number">3</span>]]</span><br><span class="line">        markup = <span class="built_in">list</span>(itertools.chain(*markup))</span><br><span class="line">        preemptives = get_preemptive(markup)</span><br><span class="line">        markup = reduce_markup(markup, preemptives)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            markups[r_s * <span class="number">3</span> + i][c_s * <span class="number">3</span>: c_s * <span class="number">3</span> + <span class="number">3</span>] = markup[i * <span class="number">3</span>:i * <span class="number">3</span> + <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>Now we have reached the step where the markup can no longer be reduced and we do not have solution yet. We will make a guess on the first empty cell available, then repeat the above step. To make this easier, we will make the above block of codes function.</p><p><img src="http://pi.math.cornell.edu/~mec/Summer2009/meerkamp/Site/Solving_any_Sudoku_II_files/mepham_markup.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">crook</span>(<span class="params">grid</span>):</span><br><span class="line">    </span><br><span class="line">    markups = get_markup(grid)</span><br><span class="line">    previous_markups = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> markups != previous_markups:</span><br><span class="line"></span><br><span class="line">        previous_markups = markups</span><br><span class="line"></span><br><span class="line"><span class="comment">#         def_row, def_col = next_definite(markups)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#         if def_row is not None:</span></span><br><span class="line"><span class="comment">#             grid[def_row][def_col] = markups[def_row][def_col][0]</span></span><br><span class="line"><span class="comment">#             markups = get_markup(grid)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            markup = markups[row]</span><br><span class="line">            preemptives = get_preemptive(markup)</span><br><span class="line">            markup = reduce_markup(markup, preemptives)</span><br><span class="line">            markups[row] = markup</span><br><span class="line"></span><br><span class="line">        markups = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">list</span>, <span class="built_in">zip</span>(*markups)))</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            markup = markups[col]</span><br><span class="line">            preemptives = get_preemptive(markup)</span><br><span class="line">            markup = reduce_markup(markup, preemptives)</span><br><span class="line">            markups[col] = markup</span><br><span class="line">        markups = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">list</span>, <span class="built_in">zip</span>(*markups))) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r_s, c_s <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">3</span>), <span class="built_in">range</span>(<span class="number">3</span>)):</span><br><span class="line">            markup = [r[c_s * <span class="number">3</span>:c_s * <span class="number">3</span> + <span class="number">3</span>] <span class="keyword">for</span> r <span class="keyword">in</span> markups[r_s * <span class="number">3</span>:r_s * <span class="number">3</span> + <span class="number">3</span>]]</span><br><span class="line">            markup = <span class="built_in">list</span>(itertools.chain(*markup))</span><br><span class="line">            preemptives = get_preemptive(markup)</span><br><span class="line">            markup = reduce_markup(markup, preemptives)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                markups[r_s * <span class="number">3</span> + i][c_s * <span class="number">3</span>: c_s * <span class="number">3</span> + <span class="number">3</span>] = markup[i * <span class="number">3</span>:i * <span class="number">3</span> + <span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line">    empty_row, empty_col = next_empty(grid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> empty_row <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span>(grid)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> guess <span class="keyword">in</span> markups[empty_row][empty_col]:</span><br><span class="line">        <span class="comment">#print(&quot;Guess in (&#123;r&#125;,&#123;c&#125;):&#123;n&#125;&quot;.format(r=empty_row, c=empty_col, n=guess))</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> check_conditions(grid, empty_row, empty_col, guess):</span><br><span class="line">            grid[empty_row][empty_col] = guess</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> crook(grid):</span><br><span class="line">                <span class="keyword">return</span>(grid)</span><br><span class="line">        </span><br><span class="line">        grid[empty_row][empty_col] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grid = [[<span class="number">2</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">8</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">9</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grid_sol = crook(grid)</span><br><span class="line">grid_sol</span><br></pre></td></tr></table></figure><pre><code>[[2, 9, 5, 7, 4, 3, 8, 6, 1], [4, 3, 1, 8, 6, 5, 9, 2, 7], [8, 7, 6, 1, 9, 2, 5, 4, 3], [3, 8, 7, 4, 5, 9, 2, 1, 6], [6, 1, 2, 3, 8, 7, 4, 9, 5], [5, 4, 9, 2, 1, 6, 7, 3, 8], [7, 6, 3, 5, 2, 4, 1, 8, 9], [9, 2, 8, 6, 7, 1, 3, 5, 4], [1, 5, 4, 9, 3, 8, 6, 7, 2]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">validateSolution(grid_sol)</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><p>Voila! We solved the sudoku puzzle with the Crook’s algorithm.</p><p>Below is the code put together so that you can try it yourselves!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_conditions</span>(<span class="params">grid, row, col, n</span>):   </span><br><span class="line">    <span class="comment">## check_conditions: list of lists, int, int, int -&gt; boolean</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> grid[row]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">any</span>([r[col] == n <span class="keyword">for</span> r <span class="keyword">in</span> grid]):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    r_start = (row // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    c_start = (col // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> r, c <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">3</span>),<span class="built_in">range</span>(<span class="number">3</span>)):</span><br><span class="line">        <span class="keyword">if</span> grid[r_start + r][c_start + c] == n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_markup</span>(<span class="params">grid</span>):</span><br><span class="line">    <span class="comment">## get_markup(): listof listof int -&gt; listof listof int</span></span><br><span class="line">    <span class="comment">## This helper function returns a list of list of integers</span></span><br><span class="line">    <span class="comment">## where each list of integer is a markup of a corresponding cell </span></span><br><span class="line">    markup_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        r = [[]]*<span class="number">9</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            markup = []</span><br><span class="line">            <span class="keyword">if</span> grid[row][col] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> candidate <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span> check_conditions(grid, row, col, candidate):</span><br><span class="line">                    markup.append(candidate)</span><br><span class="line"></span><br><span class="line">            r[col] = markup</span><br><span class="line"></span><br><span class="line">        markup_list.append(r)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span>(markup_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_preemptive</span>(<span class="params">listofMarkup</span>):</span><br><span class="line">    </span><br><span class="line">    preemptive_list = []</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> listofMarkup:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(m) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(m) == listofMarkup.count(m):</span><br><span class="line">                <span class="keyword">if</span> m <span class="keyword">not</span> <span class="keyword">in</span> preemptive_list:</span><br><span class="line">                    preemptive_list.append(m)</span><br><span class="line">    <span class="keyword">return</span>(preemptive_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reduce_markup</span>(<span class="params">listofMarkup, preemptive_list</span>):</span><br><span class="line">    <span class="comment"># compute row-, col- or subgrid-wise</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preemptive_list) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span>(listofMarkup)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> preemptive_list:</span><br><span class="line">        <span class="keyword">return</span>([[m <span class="keyword">for</span> m <span class="keyword">in</span> l <span class="keyword">if</span> (m <span class="keyword">not</span> <span class="keyword">in</span> p)] <span class="keyword">if</span> l != p <span class="keyword">else</span> p <span class="keyword">for</span> l <span class="keyword">in</span> listofMarkup])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">next_empty</span>(<span class="params">grid</span>):</span><br><span class="line">    <span class="comment">## next_empty(): listof lists -&gt; int, int</span></span><br><span class="line">    <span class="comment">## next_empty() is a helper function that searches for the next empty cell in the given sudoku puzzle</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> grid:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">in</span> row:</span><br><span class="line">            <span class="keyword">return</span> (grid.index(row), row.index(<span class="number">0</span>))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crook</span>(<span class="params">grid</span>):</span><br><span class="line">    </span><br><span class="line">    markups = get_markup(grid)</span><br><span class="line">    previous_markups = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> markups != previous_markups:</span><br><span class="line"></span><br><span class="line">        previous_markups = markups</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            markup = markups[row]</span><br><span class="line">            preemptives = get_preemptive(markup)</span><br><span class="line">            markup = reduce_markup(markup, preemptives)</span><br><span class="line">            markups[row] = markup</span><br><span class="line"></span><br><span class="line">        markups = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">list</span>, <span class="built_in">zip</span>(*markups)))</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            markup = markups[col]</span><br><span class="line">            preemptives = get_preemptive(markup)</span><br><span class="line">            markup = reduce_markup(markup, preemptives)</span><br><span class="line">            markups[col] = markup</span><br><span class="line">        markups = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">list</span>, <span class="built_in">zip</span>(*markups))) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r_s, c_s <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">3</span>), <span class="built_in">range</span>(<span class="number">3</span>)):</span><br><span class="line">            markup = [r[c_s * <span class="number">3</span>:c_s * <span class="number">3</span> + <span class="number">3</span>] <span class="keyword">for</span> r <span class="keyword">in</span> markups[r_s * <span class="number">3</span>:r_s * <span class="number">3</span> + <span class="number">3</span>]]</span><br><span class="line">            markup = <span class="built_in">list</span>(itertools.chain(*markup))</span><br><span class="line">            preemptives = get_preemptive(markup)</span><br><span class="line">            markup = reduce_markup(markup, preemptives)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                markups[r_s * <span class="number">3</span> + i][c_s * <span class="number">3</span>: c_s * <span class="number">3</span> + <span class="number">3</span>] = markup[i * <span class="number">3</span>:i * <span class="number">3</span> + <span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line">    empty_row, empty_col = next_empty(grid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> empty_row <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span>(grid)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> guess <span class="keyword">in</span> markups[empty_row][empty_col]:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> check_conditions(grid, empty_row, empty_col, guess):</span><br><span class="line">            grid[empty_row][empty_col] = guess</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> crook(grid):</span><br><span class="line">                <span class="keyword">return</span>(grid)</span><br><span class="line">        </span><br><span class="line">        grid[empty_row][empty_col] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">validateSolution</span>(<span class="params">sudoku</span>):</span><br><span class="line">    <span class="comment">## To check if it is a valid solution:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">## If any cell is empty:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">any</span>([<span class="number">0</span> <span class="keyword">in</span> row <span class="keyword">for</span> row <span class="keyword">in</span> sudoku]):</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> sudoku:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> row:</span><br><span class="line">                <span class="keyword">return</span>(<span class="literal">False</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> [r[col] <span class="keyword">for</span> r <span class="keyword">in</span> sudoku]:</span><br><span class="line">                    <span class="keyword">return</span>(<span class="literal">False</span>)</span><br><span class="line">                </span><br><span class="line">    </span><br><span class="line">        <span class="comment">## In fact, if row and column-wise conditions are met, then subgrid condition is automatically met. </span></span><br><span class="line">        <span class="comment">## But we want to check it explicitly.</span></span><br><span class="line">        <span class="keyword">for</span> r_start, c_start <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">3</span>),<span class="built_in">range</span>(<span class="number">3</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">any</span>([n <span class="keyword">not</span> <span class="keyword">in</span> row[c_start * <span class="number">3</span>: c_start * <span class="number">3</span> + <span class="number">3</span>] <span class="keyword">for</span> row <span class="keyword">in</span> grid[r_start * <span class="number">3</span>: r_start * <span class="number">3</span> + <span class="number">3</span>]]):</span><br><span class="line">                <span class="keyword">return</span>(<span class="literal">False</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Rule-of-Sudoku&quot;&gt;&lt;a href=&quot;#Rule-of-Sudoku&quot; class=&quot;headerlink&quot; title=&quot;Rule of Sudoku&quot;&gt;&lt;/a&gt;Rule of Sudoku&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Every square has to contain a single number&lt;/li&gt;
&lt;li&gt;Only the numbers between 1 and 9 (inclusive) can be used&lt;/li&gt;
&lt;li&gt;Each 3×3 subgrid can only contain each number from 1 to 9 once&lt;/li&gt;
&lt;li&gt;Each column can only contain each number from 1 to 9 once&lt;/li&gt;
&lt;li&gt;Each row can only contain each number from 1 to 9 once</summary>
    
    
    
    
    <category term="Python" scheme="http://michaelhur.github.io/tags/Python/"/>
    
    <category term="Sudoku" scheme="http://michaelhur.github.io/tags/Sudoku/"/>
    
    <category term="Crook" scheme="http://michaelhur.github.io/tags/Crook/"/>
    
    <category term="Algorithm" scheme="http://michaelhur.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Github, Jekyll과 Minimal Mistakes를 이용하여 블로그 만들기</title>
    <link href="http://michaelhur.github.io/2021/06/02/blogging/"/>
    <id>http://michaelhur.github.io/2021/06/02/blogging/</id>
    <published>2021-06-02T09:18:42.000Z</published>
    <updated>2021-06-02T09:18:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="선택-장애-플랫폼-선택하기"><a href="#선택-장애-플랫폼-선택하기" class="headerlink" title="선택 장애: 플랫폼 선택하기"></a>선택 장애: 플랫폼 선택하기</h3><p>블로그를 시작하기로 하면서 플랫폼을 결정하는 것이 가장 힘들었다. <span id="more"></span>큰 수정 없이 out-of-box로 블로깅을 시작할 수 있는 Wordpress와 Tistory 등의 플랫폼이 존재하였지만 개발을 하면서 익숙해져있던 Github에 더 눈이 갔기때문이다. 개발자라면 누구나 한번쯤은 사용해봤을 Github는 version control, code review등 코딩 환경을 제공해줄뿐만 아니라 Github Pages를 통하여 개인 프로젝트 페이지를 “무료”로 호스팅해준다.기존에 Github를 사용하고 있던 나로서는 Github Pages를 꾸미는데 필요한 Markdown이라는 기술에 이미 익숙해져 있었기에 Github Pages로 블로깅을 시작하기로 하였다.<br><br></p><h3 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h3><p>Github Pages만으로는 광활한 흰 화면에 글자만 남는 무미건조한 블로그가 만들어진다. 임시방편으로 게시물마다 Markdown을 사용하여 사진과 동영상을 넣을 수 있지만 이는 말 그대로 임시방편. 결국은 기본적인 디자인을 꾸며야했다. Github Pages와 같은 static website를 꾸며주는 static content site builder가 필요했고 가장 유명한 Jekyll을 선택하기로 하였다. 물론 가장 유명하다는 이유로 선택한 것은 아니다. Jekyll을 사용하기 위해서 새로운 프로그래밍 언어를 배워야했다면 다른 선택지를 고려해봤을 것이다. 하지만 그럴 필요가 없었고 아래와 같은 장점이 있었기에 Jekyll가 최선의 선택이라고 생각되었다.<br><br>  </p><h4 id="Jekyll은"><a href="#Jekyll은" class="headerlink" title="Jekyll은"></a>Jekyll은</h4><ul><li><p>텍스트기반의 블로깅 환경 - Markdown또는 HTML로 블로그를 작성한다. 기존에 Github를 사용하고 있었던 사람이라면 자신의 프로젝트또는 Repository를 어필하기 위하여 Readme.MD를 수정한 경험이 많을 것이다. 텍스트로만 작성하여야하고 이미지또는 비디오의 경우 코드를 사용하여 넣어야하는 불편함이 존재하지만 그 외 테크관련 블로그에서 흔히 볼 수 있는 “코드 강조” 같은 기능이 매우 쉽게 구현되어있어 기술적인 내용을 서술할때 매우 편리하다.</p></li><li><p>Github와의 연동 - Github가 공식적으로 지원하고 있으며 무료로 호스팅을 해주고있다. Wordpress같은 경우에는 $5정도의 호스팅비를 매 달 납부하여야하며 (지금은 모두에게 오픈되어있지만) Tistory의 경우에는 초대장이 있어야만 사용 가능하였다. 공짜라는 장점과 개발자에게는 Google같이 익숙한 Github와 연동이 된다는 점이 마음에 들었다</p></li></ul><h4 id="Minimal-Mistakes-Theme"><a href="#Minimal-Mistakes-Theme" class="headerlink" title="Minimal Mistakes Theme"></a>Minimal Mistakes Theme</h4><p>Jekyll기반 블로그를 만들면서 레이아웃부터 만들 이유가 없었다. 그랬다면 Jekyll을 선택하지도 않았을 것이며 Github Pages대신 Tistory나 Wordpress같이 여러가지 스킨을 기본적으로 제공해주는 플랫폼을 찾아보고 있었을 것이다. 다행히도 Jekyll 역시 이러한 Theme을 제공하고 있었으며 나는 가장 심플하면서도 내가 필요로 하는 기능을 갖추고 있는 Minimal Mistakes Theme을 택하였다. 화려한 기능과 디자인을 가진 테마들이 여럿 존재하였지만 블로그는 블로그답게 최대한 내용에 집중할 수 있도록 심플한 스킨을 선택했으며, 이는 추후에 몇번의 클릭과 몇 줄의 코드만으로 새로운 것을 추가할 수 있었기에 내 인생 모토인 “Keep it simple, stupid.”에 충실하기로 하였다.</p><br> <br> ### 우분투에서 Jekyll 시작하기<h5 id="1-Github-Pages-만들기"><a href="#1-Github-Pages-만들기" class="headerlink" title="1. Github Pages 만들기"></a>1. Github Pages 만들기</h5><p>우선적으로 해야하는 것은 블로그를 호스팅할 Github Pages를 만드는 것이다. 이는 매우 간단한데 아래와 같이 본인의 Github 페이지에서 New Repository를 만드는 과정과 같다.</p><p><img src="https://michaelhur.github.io/images/20210602/githubpages1.png"></p><p>여기서 다른 점은 Repository의 이름을 (username).github.io로 지정해주어야한다.</p><p><img src="https://michaelhur.github.io/images/20210602/githubpages2.png"></p><p>Github Pages를 만든 후에는 아래와 같은 bash command를 실행하여 블로그의 내용을 저장할 폴더를 복사해오면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/(username).github.io.git</span><br></pre></td></tr></table></figure><br><br>##### 2. Jekyll 설치 <p>이제 Github Pages를 만들었으니 블로그를 만들 Jekyll을 설치할 차례다. Jekyll은 Ruby라는 프로그래밍 언어로 만들졌으며, 사용하기 위해서는 Ruby를 설치해야한다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ruby-full</span><br></pre></td></tr></table></figure><p>Ruby를 설치하였으니 Jekyll을 설치할 차례다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install jekyll</span><br></pre></td></tr></table></figure><p>끝!<br><br><br><br></p><h5 id="3-원하는-Jekyll-Theme-적용하기"><a href="#3-원하는-Jekyll-Theme-적용하기" class="headerlink" title="3. 원하는 Jekyll Theme 적용하기"></a>3. 원하는 Jekyll Theme 적용하기</h5><p><a href="https://jekyllthemes.io/">https://jekyllthemes.io/</a> 에는 많은 Jekyll Theme을 제공하고 있다. 마음에 드는 Theme을 찾아서 다운로드만 하면 끝. 다운로드를 한 Theme은 위에 복사해온 <code>(username).github.io</code> 폴더에 복사하면 된다.<br><br><br><br></p><h5 id="4-테스팅"><a href="#4-테스팅" class="headerlink" title="4. 테스팅"></a>4. 테스팅</h5><p>제대로 설치되었는지 확인하기 위해서, 그리고 추후에 블로그 포스트를 작성하는 과정에서 내용을 확인할때 아래와 같이 테스트를 하면 된다. 이는 실제로 블로그를 호스팅하는 (username).github.io 페이지에 전혀 영향을 주지않는다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> username.github.io</span><br><span class="line">jekyll build</span><br><span class="line">jekyll serve</span><br></pre></td></tr></table></figure><br><br>##### 5. Github Pages에 업로드<p>내가 작성한 블로그 포스트가 아무런 문제가 없었다면 이제는 블로그에 업로드할 차례이다. Github Pages라고 기존 Github Repository와 별반 다를바 없다. 아래와 같은 bash command로 Github에 업로드하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> username.github.io</span><br><span class="line">git init</span><br><span class="line">git remote add origin https://github.com/username/username.github.io.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;message&quot;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>아무런 오류가 없이 끝났다면 본인의 블로그 페이지인 <code>username.github.io</code>에서 확인해보자.<br><br><br><br></p><h5 id="6-추가-기능-설치-Google-Analytics"><a href="#6-추가-기능-설치-Google-Analytics" class="headerlink" title="6. 추가 기능 설치: Google Analytics"></a>6. 추가 기능 설치: Google Analytics</h5><p>먼저 Google Analytics를 사용하기 위해서는 Google 계정이 필요하다. 가입후 추적하고자하는 블로그의 url주소를 입력하면 추적 ID가 주어진다. </p><p>추적 ID를 복사하여 아래와 같이 입력후 <code>google_analytics.html</code> 라는 이름으로 <code>_includes</code> 폴더에 저장하면 된다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  (<span class="keyword">function</span>(<span class="params">i,s,o,g,r,a,m</span>)&#123;i[<span class="string">&#x27;GoogleAnalyticsObject&#x27;</span>]=r;i[r]=i[r]||<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">  (i[r].<span class="property">q</span>=i[r].<span class="property">q</span>||[]).<span class="title function_">push</span>(<span class="variable language_">arguments</span>)&#125;,i[r].<span class="property">l</span>=<span class="number">1</span>*<span class="keyword">new</span> <span class="title class_">Date</span>();a=s.<span class="title function_">createElement</span>(o),</span></span><br><span class="line"><span class="language-javascript">  m=s.<span class="title function_">getElementsByTagName</span>(o)[<span class="number">0</span>];a.<span class="property">async</span>=<span class="number">1</span>;a.<span class="property">src</span>=g;m.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(a,m)</span></span><br><span class="line"><span class="language-javascript">  &#125;)(<span class="variable language_">window</span>,<span class="variable language_">document</span>,<span class="string">&#x27;script&#x27;</span>,<span class="string">&#x27;https://www.google-analytics.com/analytics.js&#x27;</span>,<span class="string">&#x27;ga&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">ga</span>(<span class="string">&#x27;create&#x27;</span>, <span class="string">&#x27;추적 ID&#x27;</span>, <span class="string">&#x27;auto&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">ga</span>(<span class="string">&#x27;send&#x27;</span>, <span class="string">&#x27;pageview&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이 후 <code>_layout</code>폴더에 있는 <code>default.html</code>파일을 열어 아래와 같이 코드를 추가하여야 한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;% include google_analytics.html %&#125; </span><br></pre></td></tr></table></figure><p>마지막으로 <code>_config.yml</code>파일을 열어 아래의 코드를 입력 후 저장하면 끝.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google_analytics: 추적_ID</span><br></pre></td></tr></table></figure><br><br>#### 끝내면서<p>블로그를 쓰기로 시작하면서 Github Pages를 플랫폼으로 선택하였고 Jekyll을 이용하며 블로그의 토대를 만드는 작업을 하였다. 아무래도 Tistory나 Wordpress에 비해서 기본 토대가 짜여져있지않은 플랫폼을 선택하다보니 해당 블로그 포스트를 작성하는 것보다 블로그 자체를 만드는데 더 많은 시간을 투자하게 되었다.<br>하지만 이 단계는 처음 블로그를 만든 순간과 추후에 새로운 기능을 추가할때 빼고는 딱히 신경쓰지 않아도 되는 부분이니 만큼 이제는 블로그를 채워넣을 내용에 집중할 수 있어서 좋다.</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;선택-장애-플랫폼-선택하기&quot;&gt;&lt;a href=&quot;#선택-장애-플랫폼-선택하기&quot; class=&quot;headerlink&quot; title=&quot;선택 장애: 플랫폼 선택하기&quot;&gt;&lt;/a&gt;선택 장애: 플랫폼 선택하기&lt;/h3&gt;&lt;p&gt;블로그를 시작하기로 하면서 플랫폼을 결정하는 것이 가장 힘들었다.</summary>
    
    
    
    <category term="category1" scheme="http://michaelhur.github.io/categories/category1/"/>
    
    
    <category term="Github" scheme="http://michaelhur.github.io/tags/Github/"/>
    
    <category term="Blog" scheme="http://michaelhur.github.io/tags/Blog/"/>
    
    <category term="Jekyll" scheme="http://michaelhur.github.io/tags/Jekyll/"/>
    
    <category term="Minimal Mistakes" scheme="http://michaelhur.github.io/tags/Minimal-Mistakes/"/>
    
  </entry>
  
</feed>
